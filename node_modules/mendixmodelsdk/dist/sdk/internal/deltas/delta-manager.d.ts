import { Delta } from "./deltas";
import { common } from "../../../common";
import { AbstractModel } from "../abstract-model";
export interface IDeltaManager {
    readonly isClosing: boolean;
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    push(delta: Delta): void;
    processDeltas(deltas: Delta[]): void;
    reverseDelta(delta: Delta): Delta;
    onNewDelta(callback: (delta: Delta) => void): void;
    onTransactionWillCommit(callback: () => void): void;
    onTransactionDidCommit(callback: () => void): void;
}
export declare class DeltaManager implements IDeltaManager {
    private model;
    private deltaSender;
    private deltaReverser;
    private deltaProcessor;
    private transactionChecks;
    private transactionPending;
    private closeCallback;
    private errorCallback;
    private eventEmitter;
    private static NEW_DELTA;
    private static TRANSACTION_WILL_COMMIT;
    private static TRANSACTION_DID_COMMIT;
    constructor(model: AbstractModel);
    readonly isClosing: boolean;
    /**
     * Closes the "connection" with the Model API Server in the sense that
     * pending delta requests are processed, and that afterwards the given
     * `callback` will be called.
     * This function can only be called once.
     */
    closeConnection(closeCallback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Pushes the given `delta` on the queue for scheduling/processing.
     */
    push(delta: Delta): void;
    processDeltas(deltas: Delta[]): void;
    reverseDelta(delta: Delta): Delta;
    onNewDelta(callback: (delta: Delta) => void): void;
    onTransactionWillCommit(callback: () => void): void;
    onTransactionDidCommit(callback: () => void): void;
    checkDetachedStructures: boolean;
    private callCloseCallback();
    private callErrorCallback(error);
    private scheduleCommitTransaction();
    private commitTransaction();
}

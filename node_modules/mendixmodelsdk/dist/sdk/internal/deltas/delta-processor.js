"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var units_1 = require("../units");
var elements_1 = require("../elements");
var properties_1 = require("../properties");
var instances_1 = require("../instances");
var deltaUtils = require("./delta-utils");
var DeltaProcessor = /** @class */ (function () {
    function DeltaProcessor(model) {
        this.model = model;
    }
    DeltaProcessor.prototype.processDeltas = function (deltas) {
        for (var _i = 0, deltas_1 = deltas; _i < deltas_1.length; _i++) {
            var delta = deltas_1[_i];
            var unit = deltaUtils.getUnitForDelta(this.model, delta);
            switch (delta.deltaType) {
                case "UPDATE_PROPERTY_VALUE":
                    this.processUpdatePropertyValueDelta(unit, delta);
                    break;
                case "CREATE_ELEMENT_TREE":
                    this.processCreateElementTreeDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "DELETE_ELEMENT":
                    this.processDeleteElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "ATTACH_ELEMENT":
                    this.processAttachElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "DETACH_ELEMENT":
                    this.processDetachElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                default:
                    throw new Error("Delta type " + delta.deltaType + " is not supported.");
            }
        }
    };
    DeltaProcessor.prototype.processUpdatePropertyValueDelta = function (unit, delta) {
        var _this = this;
        var structure = unit instanceof units_1.StructuralUnit ? unit :
            deltaUtils.findElement(this.model, deltaUtils.asModelUnit(unit), delta.elementId);
        var property = deltaUtils.findProperty(structure, delta.propertyName);
        if (property instanceof properties_1.PartProperty || property instanceof properties_1.PartListProperty) {
            throw new Error("Cannot apply UPDATE_PROPERTY_VALUE delta to part (list) properties");
        }
        if (property instanceof properties_1.StructuralChildProperty || property instanceof properties_1.StructuralChildListProperty) {
            throw new Error("Cannot apply UPDATE_PROPERTY_VALUE delta to structural child (list) properties");
        }
        deltaUtils.checkMutator(delta.mutator, property);
        deltaUtils.updateStructure(structure, function () {
            _this.processMutator(structure, property, delta.mutator);
        });
    };
    DeltaProcessor.prototype.processMutator = function (structure, property, mutator) {
        switch (mutator.mutatorType) {
            case "CHANGE":
                if (deltaUtils.isListProperty(property)) {
                    var rawList_1 = deltaUtils.rawList(property);
                    rawList_1[mutator.updateIndex] = mutator.value;
                    property.updateWithRawValue(rawList_1);
                }
                else {
                    property.updateWithRawValue(mutator.value);
                    if (property instanceof properties_1.ByIdReferenceProperty) {
                        property.resolveReference();
                    }
                    if (property instanceof properties_1.PrimitiveProperty && property.name === "name") {
                        // Needs to be done to update client cache and client renaming, will not run automatically when _isUpdating is true.
                        structure._processNameChange();
                    }
                }
                break;
            case "ADD":
                var index = util_1.isNumber(mutator.insertionIndex) ? mutator.insertionIndex : property.get().length;
                var rawList = deltaUtils.rawList(property);
                rawList.splice(index, 0, mutator.value);
                property.updateWithRawValue(rawList);
                break;
            case "REMOVE":
                property.get().splice(mutator.removalIndex, 1);
                break;
            default:
                throw new Error("Invalid mutatorType: " + JSON.stringify(mutator));
        }
    };
    DeltaProcessor.prototype.processCreateElementTreeDelta = function (unit, delta) {
        if (!delta.elementTree) {
            throw new Error("Missing elementTree");
        }
        var parentElement = deltaUtils.findElement(this.model, unit, delta.parentId);
        var parentProperty = deltaUtils.findProperty(parentElement, delta.parentPropertyName);
        var newElement;
        if (parentProperty instanceof properties_1.PartProperty) {
            parentProperty.updateWithRawValue(delta.elementTree);
            newElement = parentProperty.get();
        }
        else if (parentProperty instanceof properties_1.PartListProperty) {
            newElement = instances_1.instancehelpers.modelElementJsonToInstance(this.model, unit, parentElement, delta.elementTree, false);
            deltaUtils.updateStructure(parentElement, function () {
                if (delta.additionIndex !== undefined) {
                    deltaUtils.checkInsertionIndex(delta.additionIndex, parentProperty);
                    parentProperty.get().splice(delta.additionIndex, 0, newElement);
                }
                else {
                    parentProperty.get().push(newElement);
                }
            });
        }
        else {
            throw new Error("CREATE_ELEMENT_TREE parent property should be a PartProperty or PartListProperty");
        }
        // This is needed because updateWithRawValue does not automatically add the new element to the QN cache.
        unit.model._qualifiedNameCache.addStructureToCache(newElement);
        // This is needed because creating an element from JSON does not automatically resolve by-id references.
        unit.resolveByIdReferences();
    };
    DeltaProcessor.prototype.processDeleteElementDelta = function (unit, delta) {
        var element = deltaUtils.findElement(this.model, unit, delta.elementId);
        if (element._isDetached) {
            throw new Error("Cannot delete a detached element");
        }
        deltaUtils.updateStructure(element, function () {
            if (element.container) {
                var handle = element.container._childHandle(element);
                var property = handle.containingProperty;
                if (property instanceof properties_1.PartListProperty) {
                    property.detachChild(element);
                }
                else if (property instanceof properties_1.PartProperty) {
                    property.detachValue();
                }
            }
            element._deleteInternal();
        });
    };
    DeltaProcessor.prototype.processAttachElementDelta = function (unit, delta) {
        var element = this.model.detachedStructures.filter(function (e) { return e.id === delta.elementId; })[0];
        if (!element) {
            throw new Error("Cannot find detached element with ID '" + delta.elementId + "'");
        }
        var parentElement = deltaUtils.findElement(this.model, unit, delta.newParentId);
        var parentProperty = deltaUtils.findProperty(parentElement, delta.newParentPropertyName);
        if (parentProperty instanceof properties_1.PartProperty) {
            if (parentProperty.get()) {
                throw new Error("Cannot attach element to PartProperty that already has a value");
            }
            deltaUtils.updateStructure(element, function () { return parentProperty.set(element); });
        }
        else if (parentProperty instanceof properties_1.PartListProperty) {
            deltaUtils.updateStructure(element, function () {
                if (delta.newIndex !== undefined) {
                    deltaUtils.checkInsertionIndex(delta.newIndex, parentProperty);
                    parentProperty.get().splice(delta.newIndex, 0, element);
                }
                else {
                    parentProperty.get().push(element);
                }
            });
        }
        else {
            throw new Error("ATTACH_ELEMENT new parent property should be a PartProperty or PartListProperty");
        }
    };
    DeltaProcessor.prototype.processDetachElementDelta = function (unit, delta) {
        var element = deltaUtils.findElement(this.model, unit, delta.elementId);
        if (!(element instanceof elements_1.Element)) {
            throw new Error("Cannot detach a model unit");
        }
        if (!element._isAttached) {
            throw new Error("Cannot detach an element that is already detached");
        }
        deltaUtils.updateStructure(element, function () { return element.detach(); });
    };
    return DeltaProcessor;
}());
exports.DeltaProcessor = DeltaProcessor;
//# sourceMappingURL=delta-processor.js.map
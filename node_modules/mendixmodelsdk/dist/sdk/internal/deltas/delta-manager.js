"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var delta_sender_1 = require("./delta-sender");
var delta_reverser_1 = require("./delta-reverser");
var delta_processor_1 = require("./delta-processor");
var delta_utils_1 = require("./delta-utils");
var transaction_checks_1 = require("../transaction-checks");
// tslint:disable-next-line
var EventEmitter = require("wolfy87-eventemitter");
var DeltaManager = /** @class */ (function () {
    function DeltaManager(model) {
        var _this = this;
        this.model = model;
        /** @internal */
        this.queue = [];
        this.transactionPending = false;
        this.eventEmitter = new EventEmitter();
        this.deltaSender = new delta_sender_1.DeltaSender(model, function () { return _this.callCloseCallback(); }, function (error) { return _this.callErrorCallback(error); });
        this.deltaReverser = new delta_reverser_1.DeltaReverser(model);
        this.deltaProcessor = new delta_processor_1.DeltaProcessor(model);
        this.transactionChecks = new transaction_checks_1.TransactionChecks(model);
    }
    Object.defineProperty(DeltaManager.prototype, "isClosing", {
        get: function () {
            return this.deltaSender.isClosing;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Closes the "connection" with the Model API Server in the sense that
     * pending delta requests are processed, and that afterwards the given
     * `callback` will be called.
     * This function can only be called once.
     */
    DeltaManager.prototype.closeConnection = function (closeCallback, errorCallback) {
        this.closeCallback = closeCallback;
        this.errorCallback = errorCallback;
        // If closeConnection is called in the same tick that deltas have been added, send the deltas.
        if (this.transactionPending) {
            this.commitTransaction();
        }
        this.deltaSender.closeConnection();
    };
    /**
     * Pushes the given `delta` on the queue for scheduling/processing.
     */
    DeltaManager.prototype.push = function (delta) {
        this.queue.push(delta);
        this.eventEmitter.emitEvent(DeltaManager.NEW_DELTA, [delta]);
        this.transactionChecks.onNewDelta(delta);
        this.scheduleCommitTransaction();
    };
    DeltaManager.prototype.processDeltas = function (deltas) {
        this.deltaProcessor.processDeltas(delta_utils_1.removeUselessDeltas(deltas));
        this.deltaSender.scheduleDeltas(deltas);
    };
    DeltaManager.prototype.reverseDelta = function (delta) {
        return this.deltaReverser.reverse(delta);
    };
    DeltaManager.prototype.onNewDelta = function (callback) {
        this.eventEmitter.on(DeltaManager.NEW_DELTA, callback);
    };
    DeltaManager.prototype.onTransactionWillCommit = function (callback) {
        this.eventEmitter.on(DeltaManager.TRANSACTION_WILL_COMMIT, callback);
    };
    DeltaManager.prototype.onTransactionDidCommit = function (callback) {
        this.eventEmitter.on(DeltaManager.TRANSACTION_DID_COMMIT, callback);
    };
    Object.defineProperty(DeltaManager.prototype, "checkDetachedStructures", {
        // TODO: remove it. Only used in tests.
        set: function (value) {
            this.transactionChecks.checkDetachedStructures = value;
        },
        enumerable: true,
        configurable: true
    });
    DeltaManager.prototype.callCloseCallback = function () {
        if (this.closeCallback) {
            this.closeCallback();
        }
    };
    DeltaManager.prototype.callErrorCallback = function (error) {
        if (this.errorCallback) {
            this.errorCallback(error);
        }
        else {
            this.model._errorHandler(error);
        }
    };
    DeltaManager.prototype.scheduleCommitTransaction = function () {
        var _this = this;
        if (this.transactionPending) {
            return;
        }
        this.transactionPending = true;
        setTimeout(function () { return _this.commitTransaction(); }, 0);
    };
    DeltaManager.prototype.commitTransaction = function () {
        if (!this.transactionPending) {
            return;
        }
        this.eventEmitter.emitEvent(DeltaManager.TRANSACTION_WILL_COMMIT, this.queue);
        try {
            this.transactionChecks.check(this.queue);
        }
        catch (error) {
            this.callErrorCallback(error);
            return;
        }
        this.deltaSender.scheduleDeltas(this.queue.slice());
        this.queue.splice(0, this.queue.length);
        this.eventEmitter.emitEvent(DeltaManager.TRANSACTION_DID_COMMIT);
        this.transactionPending = false;
    };
    DeltaManager.NEW_DELTA = "NewDelta";
    DeltaManager.TRANSACTION_WILL_COMMIT = "TransactionWillCommit";
    DeltaManager.TRANSACTION_DID_COMMIT = "TransactionDidCommit";
    return DeltaManager;
}());
exports.DeltaManager = DeltaManager;
//# sourceMappingURL=delta-manager.js.map
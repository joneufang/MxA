"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
/**
 * Default implementation of {@link IModelServerClient}.
 */
var apiEndPoint = "/api/v1/";
var ModelServerClientImpl = /** @class */ (function () {
    function ModelServerClientImpl(transportation) {
        this.transportation = transportation;
        this.pendingRequests = [];
        this.MAX_PARALLEL_REQUESTS = 100;
        this.runningRequests = 0;
    }
    ModelServerClientImpl.prototype.getHeadersForModificationRequest = function () {
        if (this.editLockId) {
            return { "Edit-Lock-Id": this.editLockId };
        }
        return undefined;
    };
    ModelServerClientImpl.prototype.createWorkingCopy = function (workingCopyInfo, callback, errorCallback) {
        var data = {
            workingCopyId: workingCopyInfo.workingCopyId || "",
            name: workingCopyInfo.name,
            description: workingCopyInfo.description || "",
            avatarUrl: workingCopyInfo.avatarUrl || "",
            projectId: workingCopyInfo.projectId || "",
            longLived: workingCopyInfo.longLived === true,
            teamServerBaseRevision: workingCopyInfo.teamServerBaseRevision || -1,
            teamServerBaseBranch: workingCopyInfo.teamServerBaseBranch || "",
            setAsDefault: workingCopyInfo.setAsDefault === true
        };
        this.transportation.requestMultipartBinaryFileUpload({
            method: "post",
            url: apiEndPoint + "wc/",
            body: data,
            fileParameterName: "template",
            fileName: workingCopyInfo.template
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.loadWorkingCopyMetaData = function (workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "get", url: apiEndPoint + "wc/" + workingCopyId }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.loadUnitInterfaces = function (workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "get", url: apiEndPoint + "wc/" + workingCopyId + "/units/" }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.deleteWorkingCopy = function (workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: apiEndPoint + "wc/" + workingCopyId }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.grantAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "put", url: apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId) }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.revokeAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId) }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.checkAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId)
        }, function (response) {
            return void callback(response.hasAccess);
        }, errorCallback);
    };
    ModelServerClientImpl.prototype.grantAccessByProject = function (projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "put", url: apiEndPoint + "project/" + projectId + "/members/" + encodeURIComponent(memberOpenId) }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.revokeAccessByProject = function (projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: apiEndPoint + "project/" + projectId + "/members/" + encodeURIComponent(memberOpenId) }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.exportMpk = function (workingCopyId, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/mpk"
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    };
    ModelServerClientImpl.prototype.exportModuleMpk = function (workingCopyId, moduleId, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/module/" + moduleId + "/mpk"
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    };
    ModelServerClientImpl.prototype.startAppUpdate = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        this.transportation.request({
            method: "post",
            url: apiEndPoint + "wc/" + workingCopyId + "/updateapp"
        }, function (status) {
            _this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    };
    ModelServerClientImpl.prototype.getAppUpdateStatus = function (workingCopyId, jobId, callback, errorCallback) {
        var _this = this;
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/updateapp-status?jobid=" + jobId
        }, function (status) {
            _this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    };
    ModelServerClientImpl.prototype.loadUnitById = function (workingCopyId, unitId, callback, errorCallback) {
        this.loadUnitByIdBatched({ workingCopyId: workingCopyId, unitId: unitId, callback: callback, errorCallback: errorCallback });
    };
    ModelServerClientImpl.prototype.filterUnitsByCustomWidgetId = function (workingCopyId, widgetId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/units/filter/custom-widget?widgetId=" + widgetId
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.sendDeltas = function (workingCopyId, deltas, callback, errorCallback) {
        this.transportation.request({
            method: "post",
            url: apiEndPoint + "wc/" + workingCopyId + "/deltas",
            headers: this.getHeadersForModificationRequest(),
            body: { deltas: deltas }
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.getFiles = function (workingCopyId, options, callback, errorCallback) {
        if (!options.format) {
            options.format = "json";
        }
        var filterPostfix = options.filter ? "&filter=" + options.filter : "";
        var downloadUrl = apiEndPoint + "wc/" + workingCopyId + "/files/?format=" + options.format + filterPostfix;
        if (options.format === "json") {
            this.transportation.request({ method: "get", url: downloadUrl }, callback, errorCallback);
        }
        else if (options.format === "zip") {
            this.transportation.requestFileDownload({
                method: "get",
                url: downloadUrl
            }, this.createDownloadHandler(options.path, callback, errorCallback), errorCallback);
        }
        else {
            throw new Error("Unsupported format" + options.format);
        }
    };
    ModelServerClientImpl.prototype.getFile = function (workingCopyId, filePath, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath)
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    };
    ModelServerClientImpl.prototype.putFile = function (workingCopyId, inFilePath, filePath, callback, errorCallback) {
        this.transportation.requestMultipartBinaryFileUpload({
            method: "put",
            url: apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath),
            headers: this.getHeadersForModificationRequest(),
            fileParameterName: "file",
            fileName: inFilePath
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.deleteFile = function (workingCopyId, filePath, callback, errorCallback) {
        this.transportation.request({
            method: "delete",
            url: apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath),
            headers: this.getHeadersForModificationRequest()
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.getAppEnvironmentStatus = function (workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "wc/" + workingCopyId + "/app-environment-status",
            longTimeout: true
        }, this.handleRawDeploymentResult.bind(this, callback, errorCallback), errorCallback);
    };
    ModelServerClientImpl.prototype.getMyWorkingCopies = function (callback, errorCallback) {
        this.transportation.request({ method: "get", url: apiEndPoint + "wc/" }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.getWorkingCopyByProject = function (projectId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "project/" + projectId
        }, function (response) {
            return void callback(response.workingCopyId);
        }, errorCallback);
    };
    ModelServerClientImpl.prototype.createWorkingCopyByProject = function (projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "post",
            url: apiEndPoint + "project/" + projectId,
            body: {
                projectId: projectId,
                workingCopyId: workingCopyId
            }
        }, callback, errorCallback);
    };
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    ModelServerClientImpl.prototype.updateWorkingCopyByProject = function (projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "put",
            url: apiEndPoint + "project/" + projectId,
            body: {
                projectId: projectId,
                workingCopyId: workingCopyId
            }
        }, callback, errorCallback);
    };
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    ModelServerClientImpl.prototype.deleteWorkingCopyByProject = function (projectId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: apiEndPoint + "project/" + projectId }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.lockWorkingCopy = function (workingCopyId, lockOptionsOrCallback, callbackOrErrorCallback, errorCallback) {
        var callback;
        var lockOptions;
        if (typeof lockOptionsOrCallback === "function") {
            callback = lockOptionsOrCallback;
            errorCallback = callbackOrErrorCallback;
            lockOptions = { lockType: "bidi" };
        }
        else if (typeof lockOptionsOrCallback === "string") {
            lockOptions = { lockType: lockOptionsOrCallback };
            callback = callbackOrErrorCallback;
        }
        else {
            lockOptions = lockOptionsOrCallback;
            callback = callbackOrErrorCallback;
        }
        if (lockOptions.lockType === "edit") {
            this.editLockId = lockOptions.lockId;
        }
        this.transportation.request({
            method: "post",
            url: apiEndPoint + "wc/" + workingCopyId + "/lock",
            body: lockOptions
        }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.unlockWorkingCopy = function (workingCopyId, callback, errorCallback) {
        this.editLockId = undefined;
        this.transportation.request({ method: "post", url: apiEndPoint + "wc/" + workingCopyId + "/unlock" }, callback, errorCallback);
    };
    ModelServerClientImpl.prototype.parseAppUpdateStatus = function (status) {
        status.consistencyErrors = this.parseBuildStatus(status.buildstatus);
    };
    ModelServerClientImpl.prototype.sendGetUnitRequest = function (info) {
        var _this = this;
        this.runningRequests += 1;
        this.transportation.request({
            method: "get",
            url: apiEndPoint + "wc/" + info.workingCopyId + "/units/" + info.unitId
        }, function (data) {
            _this.completeGetUnitRequest();
            return void info.callback(data);
        }, function (error) {
            _this.completeGetUnitRequest();
            return void info.errorCallback(error);
        });
    };
    ModelServerClientImpl.prototype.createDownloadHandler = function (exportPath, callback, errorCallback) {
        var _this = this;
        if (exportPath && !fs) {
            throw new Error("cannot download asset to disk without file system");
        }
        return function (response) {
            if (exportPath) {
                _this.storeResponseAsFile(response, exportPath, function () { return void callback(null); }, errorCallback);
            }
            else {
                callback(response);
            }
        };
    };
    ModelServerClientImpl.prototype.handleRawDeploymentResult = function (callback, errorCallback, deploymentResult) {
        deploymentResult.consistencyErrors = this.parseBuildStatus(deploymentResult.buildstatus);
        callback(deploymentResult);
    };
    ModelServerClientImpl.prototype.parseBuildStatus = function (buildstatus) {
        // EPO: JSON to object conversion done here, and not earlier in the chain (like in platform-services or in the model-server)
        // because we will skip platform-services and model-server in a later story.
        try {
            if (!buildstatus) {
                return [];
            }
            return JSON.parse(buildstatus).problems;
        }
        catch (e) {
            console.error("Failed to parse deployment result: " + buildstatus);
            return [{
                    name: "BUILD_FAILED",
                    severity: "Error",
                    message: "Failed to build: " + buildstatus,
                    locations: []
                }];
        }
    };
    ModelServerClientImpl.prototype.storeResponseAsFile = function (response, outFilePath, callback, errorCallback) {
        var dirPath = path.dirname(outFilePath);
        fs.lstat(dirPath, function (err, stats) {
            if (err || !stats.isDirectory()) {
                var cwd = process.cwd();
                errorCallback(new Error("target directory " + dirPath + " does not exist relative to " + cwd));
                return;
            }
            fs.open(outFilePath, "w", function (err2, fd) {
                if (err2) {
                    errorCallback(new Error("Could not create file with path \"" + outFilePath + "\"; due to: " + err2));
                    return;
                }
                fs.writeFile(outFilePath, response, { encoding: "binary" }, function (err3) {
                    if (err3) {
                        errorCallback(new Error("Could not write to file with path \"" + outFilePath + "\"; due to: " + err3));
                        return;
                    }
                    callback(); // make sure we don't expose any arguments to the end-user
                });
            });
        });
    };
    ModelServerClientImpl.prototype.loadUnitByIdBatched = function (info) {
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS) {
            this.sendGetUnitRequest(info);
        }
        else {
            this.pendingRequests.push(info);
        }
    };
    ModelServerClientImpl.prototype.completeGetUnitRequest = function () {
        this.runningRequests -= 1;
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS && this.pendingRequests.length > 0) {
            this.sendGetUnitRequest(this.pendingRequests.shift());
        }
    };
    return ModelServerClientImpl;
}());
exports.ModelServerClientImpl = ModelServerClientImpl;
//# sourceMappingURL=model-server-client.js.map
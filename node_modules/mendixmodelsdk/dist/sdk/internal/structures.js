"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var Structure = /** @class */ (function () {
    function Structure(_model, structureTypeName, id, _isPartial, container) {
        if (_isPartial === void 0) { _isPartial = true; }
        if (container === void 0) { container = null; }
        this.structureTypeName = structureTypeName;
        this.id = id;
        /** @internal */
        this._declaredAsNamespace = false;
        /**
         * Indicates that the internal data of this element is being updated, as a result of data received from the server, so no
         * storage events should be send
         *
         * @internal
         */
        this._isUpdating = true;
        /**
         * The current state of the structure: (new|attached|detached|deleted).
         *
         * @internal
         */
        this._state = "attached";
        /**
         * used by qualified names cache to determine old name after a rename
         * @internal
         */
        this._registeredQualifiedName = null;
        /**
         * These deltas where created before the create delta of this element was submitted to the server.
         * As soon as this happens, the queue is processed and should stay empty.
         * Each element is either an delta, or a new child that was added under a specific property.
         *
         * @internal
         */
        this._pendingDeltasAfterCreate = [];
        /** @internal */
        this._properties = []; // cache, it is used very often, and doesn't change over time
        if (!_model) {
            throw new Error("Missing model argument");
        }
        if (!id) {
            throw new Error("Missing id");
        }
        if (!structureTypeName) {
            throw new Error("Missing structureTypeName");
        }
        this._model = _model;
        this._isPartial = _isPartial;
        this._container = container;
        this._state = "attached";
        this._isUpdating = true;
    }
    Object.defineProperty(Structure.prototype, "_isNew", {
        /**
         * This structure was just constructed and has not been added to the model yet.
         *
         * @internal
         */
        get: function () {
            return this._state === "new";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "_isAttached", {
        /**
         * This structure is attached somewhere in the model. This is the "normal" state for an structure.
         *
         * @internal
         */
        get: function () {
            return this._state === "attached";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "_isDetached", {
        /**
         * This structure is detached, so that it can be attached somewhere else in the model.
         *
         * @internal
         */
        get: function () {
            return this._state === "detached";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "_isDeleted", {
        /**
         * This structure has been deleted and should no longer be used.
         *
         * @internal
         */
        get: function () {
            return this._state === "deleted";
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    Structure.prototype._initializeNewInstance = function () {
        this._state = "new";
        this._isPartial = false;
        this._isUpdating = false;
        this._initializeDefaultProperties();
        this._markCurrentValuesAsDefaults();
    };
    /** @internal */
    Structure.prototype._initializeDefaultProperties = function () {
        // Empty stub, for new istances of this class, properties are initialized as described in the meta model
    };
    Object.defineProperty(Structure.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "model", {
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "versionInfo", {
        /** @internal */
        get: function () {
            // assumption: versionInfo is *not* inherited.
            return this.constructor.versionInfo;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Asserts that the complete element is available, and not just its public part.
     * @internal
     */
    Structure.prototype._assertLoaded = function (propertyForMessage) {
        if (!this.isLoaded) {
            throw new Error(propertyForMessage
                ? ("This operation is not allowed on the property '" + propertyForMessage.name + "' because its "
                    + ("parent object '" + this.structureTypeName + "' with ID '" + this.id + "' was not fully loaded. ")
                    + "Load the property's parent object with the '.load(callback)' command.")
                : ("This operation is not allowed on the object '" + this.structureTypeName + "' with ID '" + this.id + "' because "
                    + "it was not fully loaded. Load the object with the '.load(callback)' command."));
        }
    };
    /** @internal */
    Structure.prototype._registerProperty = function (prop) {
        this._properties.push(prop);
    };
    /**
     * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
     * @internal
     */
    Structure.prototype.resolveByIdReferences = function () {
        this.traverse(function (s) {
            s.loadedProperties()
                .filter(function (property) { return property instanceof by_id_reference_1.ByIdReferenceProperty; })
                .forEach(function (property) { return property.resolveReference(); });
        });
    };
    /**
     * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
     * @internal
     */
    Structure.prototype._processNameChange = function () {
        if (this.unit) {
            this.unit._model._processNameChange(this);
        }
        // else: not owned yet => cannot have incoming by-name references that need to be changed => no action required
    };
    /**
     * Update local-by-name references to this structure.
     * @internal
     */
    Structure.prototype._processLocalNameChange = function (previousName) {
        var _this = this;
        if (previousName === null || !this.unit || !(this.unit instanceof units.ModelUnit)) {
            return;
        }
        // Update local references to the previous name of structure and with the correct target type.
        this.unit.traverse(function (abstractElement) {
            for (var _i = 0, _a = abstractElement.allProperties(); _i < _a.length; _i++) {
                var property = _a[_i];
                if (property instanceof properties.LocalByNameReferenceProperty) {
                    var targetType = instances_1.instancehelpers.lookupClass(property.targetType, _this._model._allModelClasses());
                    if (_this instanceof targetType && property.localName() === previousName) {
                        property.set(_this);
                    }
                }
            }
        });
    };
    /**
     * Finds the given child among the properties of this structure,
     * returning a handle to detach it later when appropriate based on in which property is was found.
     * @internal
     */
    Structure.prototype._childHandle = function (child) {
        var props = this.allProperties();
        var _loop_1 = function (i) {
            var prop = props[i];
            if (prop instanceof properties.PartListProperty) {
                var partListProp_1 = prop;
                if (partListProp_1.observableValue.indexOf(child) > -1) {
                    return { value: {
                            containingProperty: prop,
                            delete: function () { return partListProp_1.removeChild(child); },
                            detach: function () { return partListProp_1.detachChild(child); }
                        } };
                }
            }
            else if (prop instanceof properties.PartProperty && prop.get() === child) {
                return { value: {
                        containingProperty: prop,
                        delete: function () { return prop.set(null); },
                        detach: function () { return prop.detachValue(); }
                    } };
            }
            else if (prop instanceof properties.StructuralChildProperty && prop.get() === child) {
                return { value: {
                        containingProperty: prop,
                        delete: function () { return prop.set(null); },
                        detach: function () { return prop.detachValue(); }
                    } };
            }
            else if (prop instanceof properties.StructuralChildListProperty) {
                var partListProp_2 = prop;
                if (partListProp_2.observableValue.indexOf(child) > -1) {
                    return { value: {
                            containingProperty: prop,
                            delete: function () { return partListProp_2.removeChild(child); },
                            detach: function () { return partListProp_2.detachChild(child); }
                        } };
                }
            }
        };
        for (var i = 0; i < props.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return null;
    };
    /**
     * Detaches the given child from any (part) property that contained it.
     * @internal
     */
    Structure.prototype._detachChild = function (child) {
        var handle = this._childHandle(child);
        if (handle) {
            handle.detach();
        }
    };
    /**
     * Deletes the given child from any (part) property that contained it.
     * @internal
     */
    Structure.prototype._deleteChild = function (child) {
        var handle = this._childHandle(child);
        if (handle) {
            handle.delete();
        }
    };
    /**
     * This model element is no longer part of the model, and can be cleaned up.
     * @internal
     */
    Structure.prototype._dispose = function () {
        // NB: version-wise 'unavailable' props are included!
        this._properties.forEach(function (prop) { return prop.dispose(); });
        // TODO: clean from element cache if element, clean from global cache if unit, delete this.unit.elementsCache[this.id];
    };
    /**
     * Update an existing (probably partial) interface with real contents received from the server.
     * @internal
     */
    Structure.prototype._updateWithJson = function (json) {
        // Only allow to go from partial to full documents once, of course, later on, a full merge would be required
        this._isPartial = false;
        this._isUpdating = true;
        this._updateWithJsonImpl(json);
        this._isUpdating = false;
    };
    /** @internal */
    Structure.prototype._updateWithJsonImpl = function (json) {
        for (var key in json) {
            if (key !== "$ID" && key !== "$Type" && this["__" + key] instanceof abstract_property_1.AbstractProperty) {
                this["__" + key].updateWithRawValue(json[key]);
            }
        }
    };
    /** @internal */
    Structure.prototype._scheduleDeltaAfterCreate = function (delta) {
        // if the create was not send yet to the server, delay this delta until that is done:
        if (this._isNew) {
            this._pendingDeltasAfterCreate.push(delta);
        }
        else {
            delta.unitId = this.unit.id;
            this.unit._model._sendDelta(delta);
        }
    };
    /**
     * Sends the change delta in case a simple property has changed.
     * @internal
     */
    Structure.prototype._sendChangeDelta = function (propertyName, newValue, changeType, index) {
        if (changeType === void 0) { changeType = "CHANGE"; }
        if (index === void 0) { index = -1; }
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var mutator = (function () {
            switch (changeType) {
                case "CHANGE":
                    var changeMutator = {
                        value: newValue,
                        mutatorType: changeType
                    };
                    if (index >= 0) {
                        changeMutator.updateIndex = index;
                    }
                    return changeMutator;
                case "ADD":
                    return {
                        value: newValue,
                        mutatorType: changeType,
                        insertionIndex: index
                    };
                case "REMOVE":
                    return {
                        removalIndex: index,
                        mutatorType: changeType
                    };
                default: {
                    throw new Error("Unknown mutator type '" + changeType + "'");
                }
            }
        })();
        this._scheduleDeltaAfterCreate({
            unitId: undefined,
            elementId: this.id,
            deltaType: "UPDATE_PROPERTY_VALUE",
            propertyName: propertyName,
            mutator: mutator
        });
    };
    /**
     * Sends the delete in case that we were removed from the model.
     * @internal
     */
    Structure.prototype._sendDeleteDelta = function () {
        if (this._isUpdating) {
            return;
        }
        var deleteDelta;
        if (this instanceof elements.Element) {
            this._assertLoaded();
            deleteDelta = {
                unitId: this.unit && this.unit.id,
                elementId: this.id,
                deltaType: "DELETE_ELEMENT"
            };
        }
        else if (this instanceof units.ModelUnit) {
            deleteDelta = {
                unitId: this.unit && this.unit.id,
                deltaType: "DELETE_UNIT"
            };
        }
        else {
            throw Error("Cannot send delete delta for anything but ModelUnit and Element");
        }
        this._scheduleDeltaAfterCreate(deleteDelta);
    };
    /** @internal */
    Structure.prototype._markCurrentValuesAsDefaults = function () {
        this.allProperties().forEach(function (property) {
            if (property instanceof properties.PrimitiveProperty) {
                property.markCurrentValueAsDefault();
            }
        });
    };
    /** @internal */
    Structure.prototype._deleteInternal = function () {
        this._dispose();
    };
    Structure.prototype.toJSON = function () {
        var json = {
            $ID: this.id,
            $Type: this.structureTypeName
        };
        this.allProperties().forEach(function (property) {
            var propertyValue = property._toJSON();
            json[property.name] = propertyValue;
        });
        return json;
    };
    Structure.prototype.allProperties = function () {
        return this._properties.filter(function (prop) { return prop.isAvailable; });
    };
    Structure.prototype.publicProperties = function () {
        return this._properties.filter(function (prop) { return prop.isAvailable && prop.isPublic; });
    };
    Structure.prototype.loadedProperties = function () {
        return this.isLoaded ? this.allProperties() : this.publicProperties();
    };
    /** @internal */
    Structure.prototype._traverseInternal = function (visit, excludePrivate, returnSingleResult) {
        if (excludePrivate === void 0) { excludePrivate = false; }
        if (returnSingleResult === void 0) { returnSingleResult = false; }
        var result = visit(this);
        if (returnSingleResult && result) {
            return result;
        }
        var allProperties = excludePrivate ? this.publicProperties() : this.loadedProperties();
        for (var _i = 0, allProperties_1 = allProperties; _i < allProperties_1.length; _i++) {
            var property = allProperties_1[_i];
            if (property instanceof properties.PartProperty || property instanceof properties.StructuralChildProperty) {
                var value = property.get();
                if (value) {
                    result = value._traverseInternal(visit, excludePrivate, returnSingleResult);
                    if (returnSingleResult && result) {
                        return result;
                    }
                }
            }
            else if (property instanceof properties.PartListProperty || property instanceof properties.StructuralChildListProperty) {
                var children = property.get();
                for (var _a = 0, children_1 = children; _a < children_1.length; _a++) {
                    var child = children_1[_a];
                    result = child._traverseInternal(visit, excludePrivate, returnSingleResult);
                    if (returnSingleResult && result) {
                        return result;
                    }
                }
            }
        }
        return null;
    };
    Structure.prototype.traverse = function (visit) {
        this._traverseInternal(visit);
    };
    Structure.prototype.traversePublicParts = function (visit) {
        this._traverseInternal(visit, true);
    };
    Structure.prototype.traverseFind = function (visit) {
        return this._traverseInternal(visit, false, true);
    };
    Structure.prototype.getContainerAs = function (containerType) {
        if (!(this.container instanceof containerType)) {
            throw new Error("instance of " + this.structureTypeName + " is not contained by a " + containerType.structureTypeName);
        }
        return this.container;
    };
    __decorate([
        mobx_1.observable
    ], Structure.prototype, "_container", void 0);
    return Structure;
}());
exports.Structure = Structure;
// tslint:enable:no-use-before-declare
/**
 * Late dependencies on others, structures should be defined first for proper inheritance!
 */
var elements = require("./elements");
var abstract_property_1 = require("./properties/abstract-property");
var properties = require("./properties");
var units = require("./units");
var by_id_reference_1 = require("./properties/by-id-reference");
var instances_1 = require("./instances");
//# sourceMappingURL=structures.js.map
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var version_1 = require("../../version");
var utils_1 = require("../utils");
var metamodelversion_1 = require("../../gen/metamodelversion");
// Postpone requiring the 'request' module to prevent errors when using the Model SDK in the browser.
var requestImpl;
var SHORT_TIMEOUT = 1 * 60 * 1000;
var LONG_TIMEOUT = 15 * 60 * 1000;
/**
 * Default implementation of {@link ITransportation} that communicates with the Model API Server over
 * HTTP using Request.
 */
var RestTransportation = /** @class */ (function () {
    function RestTransportation(config) {
        this.config = config;
        requestImpl = require("request");
    }
    RestTransportation.prototype.request = function (opts, success, failure) {
        var options = this.generateStandardOptions(opts.method, opts.url, true);
        if (opts.headers) {
            options.headers = __assign({}, opts.headers, options.headers);
        }
        if (opts.longTimeout) {
            options.timeout = LONG_TIMEOUT;
        }
        if (opts.body) {
            options.body = opts.body;
        }
        this.handleRequest(options, success, failure);
    };
    RestTransportation.prototype.requestMultipartBinaryFileUpload = function (opts, success, failure) {
        var options = this.generateStandardOptions(opts.method, opts.url, true);
        options.timeout = LONG_TIMEOUT; // 15 minutes: uploading mpk's takes some time, and can be quite large.
        if (!opts.fileName) {
            throw new Error("File to upload is missing.");
        }
        if (opts.headers) {
            options.headers = __assign({}, opts.headers, options.headers);
        }
        options.formData = opts.body || {};
        // Convert boolean properties to string.
        // Known issue: https://github.com/form-data/form-data/issues/137
        for (var key in options.formData) {
            if (options.formData.hasOwnProperty(key) && typeof options.formData[key] === "boolean") {
                options.formData[key] = options.formData[key].toString();
            }
        }
        options.formData[opts.fileParameterName] = fs.createReadStream(opts.fileName);
        this.handleRequest(options, success, failure);
    };
    RestTransportation.prototype.requestFileDownload = function (opts, success, failure) {
        var options = this.generateStandardOptions(opts.method, opts.url, false);
        options.encoding = null;
        options.timeout = LONG_TIMEOUT;
        this.handleRequest(options, success, failure);
    };
    RestTransportation.prototype.sanitizedMethod = function (method) {
        return method.toUpperCase();
    };
    RestTransportation.prototype.url = function (urlEndpoint) {
        var subUrl = urlEndpoint.substring("/api".length);
        return utils_1.utils.combineUrl(this.config.endPoint || "", subUrl);
    };
    RestTransportation.prototype.generateStandardOptions = function (method, url, acceptJson) {
        var options = {
            method: this.sanitizedMethod(method),
            url: this.url(url),
            timeout: SHORT_TIMEOUT,
            pool: {
                maxSockets: 20
            },
            headers: {
                "Max-Metamodel-Version": metamodelversion_1.MAX_METAMODEL_VERSION,
                "User-Agent": "mendixmodelsdk/" + version_1.SDK_VERSION + " " + process.platform + " " + process.arch + " node" + process.versions.node
            }
        };
        if (acceptJson) {
            options.json = true;
        }
        // upcasts for correct type
        var backendCredentials = this.config.credentials;
        var sdkCredentials = this.config.credentials;
        if (this.config.credentials && this.config.credentials.username) {
            options.auth = {
                username: this.config.credentials.username
            };
            if (backendCredentials.password) {
                // Backend credentials
                options.auth.password = backendCredentials.password;
                if (backendCredentials.openid) {
                    options.headers.openid = backendCredentials.openid;
                }
            }
            else if (sdkCredentials.apikey) {
                // Api key
                options.auth.password = sdkCredentials.apikey;
            }
            else {
                throw new Error("Expected either an API key or password (for selected users only)");
            }
        }
        else {
            throw new Error("No credentials provided");
        }
        return options;
    };
    RestTransportation.prototype.handleRequest = function (options, success, failure) {
        requestImpl(options, function (error, response, body) {
            if (error) {
                var errorCode = error.code;
                if (errorCode === "ECONNRESET") {
                    failure({
                        error: "Not available",
                        description: "The Mendix Model API Server is not available. Please try again later.",
                        url: options.url
                    });
                }
                else if (errorCode === "EPIPE") {
                    console.warn("Encountered EPIPE - "
                        + "assuming failure callback is already called for this request with status code 413 (Request Entity Too Large).");
                }
                else {
                    failure({
                        error: "No response",
                        description: "The Mendix Model API Server failed to respond. Result code: " + errorCode,
                        url: options.url
                    });
                }
            }
            else if (response.statusCode < 200 || response.statusCode > 299) {
                failure({
                    error: body,
                    statusCode: response.statusCode,
                    url: options.url
                });
            }
            else {
                success(body);
            }
        });
    };
    return RestTransportation;
}());
exports.RestTransportation = RestTransportation;
//# sourceMappingURL=transportation.js.map
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var mobx_1 = require("mobx");
var units_1 = require("./units");
var UndoManager = /** @class */ (function () {
    function UndoManager(_model) {
        /** @internal */
        this.undoStates = {};
        /** @internal */
        this.suspendTracking = false;
        this.model = _model;
        this.deltaManager = this.model.deltaManager;
        this.deltaManager.onNewDelta(this.onNewDelta.bind(this));
        this.deltaManager.onTransactionDidCommit(this.onChangeCompleted.bind(this));
        this.model.onUnitLoaded(this.onUnitLoaded.bind(this));
    }
    UndoManager.prototype.getUndoState = function (modelUnitId) {
        if (!modelUnitId) {
            throw new Error("modelUnitId cannot be null or undefined");
        }
        if (!this.undoStates[modelUnitId]) {
            this.undoStates[modelUnitId] = new UndoState(this.deltaManager);
        }
        return this.undoStates[modelUnitId];
    };
    UndoManager.prototype.withoutUndo = function (performAction) {
        try {
            this.suspendTracking = true;
            return performAction();
        }
        finally {
            this.suspendTracking = false;
        }
    };
    UndoManager.prototype.onNewDelta = function (delta) {
        var undoState = this.getUndoState(delta.unitId);
        if (this.suspendTracking || undoState.containsCreateUnitDeltaChange) {
            return;
        }
        if (delta.deltaType === "CREATE_UNIT") {
            undoState.containsCreateUnitDeltaChange = true;
        }
        else if (delta.deltaType === "DELETE_UNIT") {
            delete this.undoStates[delta.unitId];
        }
        else {
            if (!(this.model._units[delta.unitId] instanceof units_1.ModelUnit)) {
                return;
            }
            var change = {
                delta: delta,
                reversedDelta: this.deltaManager.reverseDelta(delta)
            };
            if (!lodash_1.isEqual(change.delta, change.reversedDelta)) {
                undoState.pendingChange.push(change);
            }
        }
    };
    UndoManager.prototype.onChangeCompleted = function () {
        for (var key in this.undoStates) {
            var undoState = this.undoStates[key];
            if (undoState) {
                if (undoState.pendingChange.length > 0) {
                    undoState.changeCompleted();
                }
                undoState.containsCreateUnitDeltaChange = false;
            }
        }
    };
    UndoManager.prototype.onUnitLoaded = function (modelUnitId) {
        this.getUndoState(modelUnitId).clear();
    };
    return UndoManager;
}());
exports.UndoManager = UndoManager;
var UndoState = /** @class */ (function () {
    function UndoState(deltaManager) {
        this.deltaManager = deltaManager;
        this.history = [];
        this.future = [];
        this.pendingChange = [];
        this.containsCreateUnitDeltaChange = false;
    }
    Object.defineProperty(UndoState.prototype, "canUndo", {
        get: function () {
            return this.history.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UndoState.prototype, "canRedo", {
        get: function () {
            return this.future.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    UndoState.prototype.undo = function () {
        if (!this.canUndo) {
            throw new Error("No undo actions available");
        }
        if (this.pendingChange.length > 0) {
            throw new Error("Cannot undo when there are pending changes");
        }
        var change = this.history.pop();
        this.deltaManager.processDeltas(change.map(function (t) { return t.reversedDelta; }).reverse());
        this.future.push(change);
    };
    UndoState.prototype.redo = function () {
        if (!this.canRedo) {
            throw new Error("No redo actions available");
        }
        if (this.pendingChange.length > 0) {
            throw new Error("Cannot redo when there are pending changes");
        }
        var change = this.future.pop();
        this.deltaManager.processDeltas(change.map(function (t) { return t.delta; }));
        this.history.push(change);
    };
    UndoState.prototype.clear = function () {
        this.history.splice(0, this.history.length);
        this.future.splice(0, this.future.length);
    };
    /** @internal */
    UndoState.prototype.changeCompleted = function () {
        if (!this.containsCreateUnitDeltaChange) {
            this.history.push(this.pendingChange.slice());
            this.future.splice(0, this.future.length);
        }
        this.pendingChange = [];
    };
    __decorate([
        mobx_1.observable.shallow
    ], UndoState.prototype, "history", void 0);
    __decorate([
        mobx_1.observable.shallow
    ], UndoState.prototype, "future", void 0);
    __decorate([
        mobx_1.computed
    ], UndoState.prototype, "canUndo", null);
    __decorate([
        mobx_1.computed
    ], UndoState.prototype, "canRedo", null);
    __decorate([
        mobx_1.action
    ], UndoState.prototype, "undo", null);
    __decorate([
        mobx_1.action
    ], UndoState.prototype, "redo", null);
    return UndoState;
}());
exports.UndoState = UndoState;
//# sourceMappingURL=undo-manager.js.map
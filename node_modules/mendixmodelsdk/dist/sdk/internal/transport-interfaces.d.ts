/**
 * Types defined in this file express JSON serialization and are shared with the Model API Server.
 * Some types (points, deltas) are used verbatim through the rest of the SDK.
 */
/**
 * The contents of the `MetaData` table (which always contains one row) in the MPR contained in the working copy's MPK.
 * This is useful to determine product version and to be able to re-export the MPR as part of an MPK
 * that can be read in by the Business Modeler.
 */
export interface IMprMetaData {
    /** docs:keep */ _ProductVersion: string;
    /** docs:keep */ _BuildVersion: string;
    /** docs:keep */ _SchemaHash: string;
}
/**
 * The meta data for a working copy (- not for the MPR).
 */
export interface IWorkingCopyMetaData {
    name: string;
    description: string;
    avatarUrl: string;
    projectId: string;
    metaModelVersion: string;
    teamServerBaseRevision?: number;
    teamServerBaseBranch?: string;
}
export interface IMergeState {
    id: string;
    requestedBy: string;
    timestamp: number;
    lockType: LockType;
    lockId?: string;
    duration?: number;
}
export declare type LockType = "bidi" | "conversion" | "edit";
export interface ILockWorkingCopyOptions {
    /**
     * The lock type, which indicates the purpose for which the working copy is locked.
     */
    lockType: LockType;
    /**
     * The lock ID to use. Only applicable for lock type "edit".
     */
    lockId?: string;
    /**
     * The duration in seconds after which the lock will expire. Only applicable for lock type "edit".
     */
    duration?: number;
}
/**
 * The representation of a working copy.
 */
export interface IWorkingCopy {
    id: string;
    metaData: IWorkingCopyMetaData;
    /**
     * OpenIDs of all users that are granted access.
     */
    members: string[];
    /**
     * The name of the MPR file within the working copy's MPK, relative to its root.
     * This will typically but not necessarily equal `project.mpr`.
     */
    mprFileName: string;
    mprMetaData: IMprMetaData;
    mergeData: IMergeState | null;
    uploadDateTime: number;
}
/**
 * The base interface of any "structure", i.e. either any unit or an element within a model unit.
 */
export interface IStructureJson {
    $Type: string;
    $ID: string;
}
/**
 * The base serialization structure of a unit, i.e. either a structural or a model unit.
 */
export interface IAbstractUnitJson extends IStructureJson {
    contents: IAbstractElementJson;
    containerId: string;
    containmentName: string;
}
/**
 * The base interface of an (model) element (within a model unit).
 * (It extends {@link IStructureJson} with a general map structure to hold arbitrary properties.)
 */
export interface IAbstractElementJson extends IStructureJson {
    [key: string]: any;
}
export interface IGetFilesOptions {
    filter?: string;
    format?: "json" | "zip";
    path?: string;
}
export interface IProblem {
    name: string;
    severity: string;
    message: string;
    locations?: IProblemLocation[];
}
export interface IProblemLocation {
    elementId?: string;
    unitId?: string;
    element?: string;
    document?: string;
    module?: string;
}
export declare type IUpdateAppJobStatus = "updating" | "resuming" | "provisioning" | "started" | "consistencyerrors" | "failed";
export interface IDeployJobStatus {
    jobid: string;
    startTime: number;
    status: IUpdateAppJobStatus;
    buildstatus: string | null;
    consistencyErrors?: IProblem[];
    appUrl?: string;
    /**
     * Used to keep track of which steps this app update went trough,
     * mainly for debugging
     *
     * @memberOf IGetUpdateAppStatusResponse
     */
    trace: string[];
}
export declare type AppState = "APP_NOT_FOUND" | "STAGING" | "UPDATING" | "STARTING" | "FAILED_STAGING" | "FAILED" | "STARTED" | "MXBUILD_STARTED" | "STOPPED" | "UNKNOWN";
export interface IEnvironmentStatus {
    name: string;
    url: string;
    profile: string;
    state: AppState;
    endpoint: string;
    instances: number;
    memory: number;
    disk: number;
    buildstatus: string | null;
    environmentId: string;
    message?: string;
    consistencyErrors?: IProblem[];
}

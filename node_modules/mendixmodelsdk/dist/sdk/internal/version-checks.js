"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
function contains(range, version) {
    if (range.start) {
        if (!Version.parse(range.start).isBeforeOrEqual(version)) {
            return false;
        }
    }
    if (range.end) {
        if (!Version.parse(range.end).isAfterOrEqual(version)) {
            return false;
        }
    }
    return true;
}
exports.contains = contains;
var Version = /** @class */ (function () {
    function Version(major, minor, patch) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        // (empty constructor)
    }
    /**
     * Parses and @returns the given string as a Version object.
     *
     * This function is memoised to keep memory and time consumption low,
     * given that only a handful of versions exist at any time anyway.
     */
    Version.parse = function (versionString) {
        if (!versionString) {
            throw new Error("versionString is null or undefined");
        }
        var version = Version.memoisMap[versionString];
        if (!version) {
            var _a = versionString.split(".").map(function (x) { return parseInt(x, 10); }), major = _a[0], minor = _a[1], patch = _a[2];
            version = new Version(major, minor, patch);
            Version.memoisMap[versionString] = version;
        }
        return version;
    };
    /**
     * Returns 0 if this version is equal to the other version.
     * Returns a negative integer if this version is strictly smaller than the other version.
     * Returns a positive integer if this version is strictly larger than the other version.
     */
    Version.prototype.compare = function (other) {
        var diff = this.major - other.major;
        if (diff !== 0) {
            return diff;
        }
        diff = this.minor - other.minor;
        if (diff !== 0) {
            return diff;
        }
        return this.patch - other.patch;
    };
    /**
     * Returns true if this version is strictly larger than the provided version.
     */
    Version.prototype.isAfter = function (other) {
        return this.compare(other) > 0;
    };
    Version.prototype.isAfterOrEqual = function (other) {
        return this.compare(other) >= 0;
    };
    /**
     * Returns true if this version is strictly smaller compared to the provided version.
     */
    Version.prototype.isBefore = function (other) {
        return this.compare(other) < 0;
    };
    Version.prototype.isBeforeOrEqual = function (other) {
        return this.compare(other) <= 0;
    };
    Version.prototype.isEqualTo = function (other) {
        return this.compare(other) === 0;
    };
    Version.prototype.toString = function () {
        return this.major + "." + this.minor + "." + this.patch;
    };
    Version.memoisMap = {};
    return Version;
}());
exports.Version = Version;
/**
 * Parses the given string as a sem-Version, ignoring non-numeric and "extra" data,
 * and padding with ".0" where necessary.
 */
function parseAsNormalizedVersion(versionString) {
    var parts = versionString.split(".", 3).map(function (p) { return p.replace(/^(\d*).*$/, function (_, nr) { return nr || "0"; }); });
    while (parts.length < 3) {
        parts.push("0");
    }
    return Version.parse(parts.join("."));
}
exports.parseAsNormalizedVersion = parseAsNormalizedVersion;
var LifeCycleState;
(function (LifeCycleState) {
    LifeCycleState[LifeCycleState["UNAVAILABLE"] = 0] = "UNAVAILABLE";
    LifeCycleState[LifeCycleState["AVAILABLE"] = 1] = "AVAILABLE";
    LifeCycleState[LifeCycleState["DEPRECATED"] = 2] = "DEPRECATED";
    LifeCycleState[LifeCycleState["REMOVED"] = 3] = "REMOVED";
})(LifeCycleState = exports.LifeCycleState || (exports.LifeCycleState = {}));
var LifeCycle = /** @class */ (function () {
    function LifeCycle(info) {
        this.introduced = null; // null indicates available in base version
        this.deprecated = null; // null indicates not deprecated anywhere
        this.deleted = null; // null indicates not removed anywhere
        this.deprecationMessage = "";
        this.deletionMessage = "";
        if (info) {
            this.introduced = info.introduced ? Version.parse(info.introduced) : null;
            this.deprecated = info.deprecated ? Version.parse(info.deprecated) : null;
            this.deleted = info.deleted ? Version.parse(info.deleted) : null;
            this.deprecationMessage = info.deprecationMessage || "";
            this.deletionMessage = info.deletionMessage || "";
        }
    }
    // TODO  make the following more symmetric
    /**
     * Yields true if this feature is available in the specified version, that is:
     * - it was in base, or added before the specified version
     * - it was not removed yet in the given version
     * - deprecation statues does not influence it results
     */
    LifeCycle.prototype.isAvailableIn = function (version) {
        if (this.isRemovedIn(version)) {
            return false;
        }
        if (!this.introduced || this.introduced.isBeforeOrEqual(version)) {
            return true;
        }
        return false;
    };
    /**
     * Yields true only if the feature is available, (added but not yet removed) and deprecated in the specified version.
     */
    LifeCycle.prototype.isDeprecatedIn = function (version) {
        return !!(this.isAvailableIn(version) && this.deprecated && this.deprecated.isBeforeOrEqual(version));
    };
    /**
     * Yields true only if this version was actively removed in the given version.
     * Doesn't yield true if the feature was not yet introduced in the given version (see isAvailableIn for that)
     */
    LifeCycle.prototype.isRemovedIn = function (version) {
        return !!(this.deleted && this.deleted.isBeforeOrEqual(version));
    };
    LifeCycle.prototype.getCurrentState = function (version) {
        if (this.isRemovedIn(version)) {
            return LifeCycleState.REMOVED;
        }
        if (!this.isAvailableIn(version)) {
            return LifeCycleState.UNAVAILABLE;
        }
        if (this.isDeprecatedIn(version)) {
            return LifeCycleState.DEPRECATED;
        }
        return LifeCycleState.AVAILABLE;
    };
    /**
     * Checks a version based on this lifecycle.
     * Returns true if something is thrown or warned, otherwise false
     */
    LifeCycle.prototype.reportVersionIssues = function (version, aboutWhatMessage, printWarnings) {
        switch (this.getCurrentState(version)) {
            case LifeCycleState.UNAVAILABLE:
                throw new Error(aboutWhatMessage + " is not yet available in Mendix version " + version + ". It was introduced in Mendix version " + this.introduced);
            case LifeCycleState.DEPRECATED:
                if (printWarnings) {
                    utils_1.utils.warnOnce(aboutWhatMessage + " is deprecated in Mendix version " + version + " (deprecated since Mendix version " + this.deprecated + ") "
                        + ("and should no longer be instantiated: " + this.deprecationMessage));
                }
                return true;
            case LifeCycleState.REMOVED:
                throw new Error(aboutWhatMessage + " can no longer be instantiated in Mendix version " + version + " "
                    + ("(removed since Mendix version " + this.deleted + "): " + this.deletionMessage + "."));
            case LifeCycleState.AVAILABLE:
                return false;
            default:
                throw new Error("Illegal state");
        }
    };
    return LifeCycle;
}());
exports.LifeCycle = LifeCycle;
var ModifierValueHistory = /** @class */ (function () {
    /**
     * defaultFallback indiciates whether the absence of a lifecycle yields true or false
     */
    function ModifierValueHistory(lifecycle, defaultFallback) {
        if (lifecycle) {
            this.latestValue = lifecycle.currentValue;
            this.changedIn = lifecycle.changedIn ? lifecycle.changedIn.map(Version.parse) : [];
            for (var i = 0; i < this.changedIn.length - 1; i++) {
                if (!this.changedIn[i + 1].isBefore(this.changedIn[i])) {
                    throw new Error("The list of version changes is not ordered correctly: " + JSON.stringify(lifecycle));
                }
            }
        }
        else {
            this.changedIn = [];
            this.latestValue = defaultFallback;
        }
    }
    ModifierValueHistory.prototype.isEnabledIn = function (version) {
        if (this.changedIn.length === 0) {
            return this.latestValue;
        }
        var nonRelevant = this.changedIn.filter(function (changedInVersion) { return version.isBefore(changedInVersion); });
        // odd or even number of toggles from now back to the relevant version ?
        return nonRelevant.length % 2 === 0 ? this.latestValue : !this.latestValue;
    };
    return ModifierValueHistory;
}());
exports.ModifierValueHistory = ModifierValueHistory;
var StructureType;
(function (StructureType) {
    StructureType[StructureType["StructuralUnit"] = 0] = "StructuralUnit";
    StructureType[StructureType["ModelUnit"] = 1] = "ModelUnit";
    StructureType[StructureType["Element"] = 2] = "Element";
})(StructureType = exports.StructureType || (exports.StructureType = {}));
var VersionInfo = /** @class */ (function () {
    function VersionInfo() {
    }
    VersionInfo.prototype.checkSameModelVersion = function (model, otherModel) {
        if (model !== otherModel) {
            throw new Error("It is not possible to combine values coming from two different models");
        }
    };
    return VersionInfo;
}());
exports.VersionInfo = VersionInfo;
var StructureVersionInfo = /** @class */ (function (_super) {
    __extends(StructureVersionInfo, _super);
    function StructureVersionInfo(info, structureType) {
        var _this = _super.call(this) || this;
        _this.structureType = structureType;
        _this.properties = {};
        _this.availability = new LifeCycle(info);
        _this.isPublic = structureType === StructureType.Element
            ? new ModifierValueHistory(info.public, false)
            : new ModifierValueHistory(null, true);
        _this.isExperimental = new ModifierValueHistory(info.experimental, false);
        var propertiesArePublicByDefault = structureType === StructureType.StructuralUnit;
        if (info.properties) {
            for (var key in info.properties) {
                _this.properties[key] = new PropertyVersionInfo(info.properties[key], propertiesArePublicByDefault);
            }
        }
        _this.defaultPropertyInfo = new PropertyVersionInfo(null, propertiesArePublicByDefault);
        return _this;
    }
    StructureVersionInfo.prototype.checkStructureVersion = function (instance, includeWarnings) {
        var availability = this.availability;
        var metaModelVersion = instance.model.metaModelVersion;
        var structureTypeName = instance.structureTypeName;
        var hasVersionIssues = availability.reportVersionIssues(metaModelVersion, "Type '" + structureTypeName + "'", includeWarnings);
        if (!hasVersionIssues) {
            if (includeWarnings && this.isExperimental && this.isExperimental.isEnabledIn(metaModelVersion)) {
                utils_1.utils.warnOnce("Type '" + structureTypeName + "' is experimental in Mendix meta model version " + metaModelVersion + " "
                    + "and should be used with care.");
            }
        }
        // There is no need to check super structures: each structure has its own complete set of annotations in the meta model.
    };
    StructureVersionInfo.prototype.getPropertyVersionInfo = function (name) {
        return this.properties[name] ? this.properties[name] : this.defaultPropertyInfo;
    };
    return StructureVersionInfo;
}(VersionInfo));
exports.StructureVersionInfo = StructureVersionInfo;
var PropertyVersionInfo = /** @class */ (function (_super) {
    __extends(PropertyVersionInfo, _super);
    function PropertyVersionInfo(info, publicByDefault) {
        var _this = _super.call(this) || this;
        _this.availability = new LifeCycle(info);
        _this.isPublic = new ModifierValueHistory(info ? info.public : null, publicByDefault);
        _this.isRequired = new ModifierValueHistory(info ? info.required : null, false);
        return _this;
    }
    PropertyVersionInfo.prototype.checkPropertyVersion = function (property, includeWarnings) {
        var name = property.name;
        var metaModelVersion = property.parent.model.metaModelVersion;
        var availability = property.parent.versionInfo.getPropertyVersionInfo(name).availability;
        var structureTypeName = property.parent.structureTypeName;
        availability.reportVersionIssues(metaModelVersion, "Property '" + name + "' of type '" + structureTypeName + "'", includeWarnings);
    };
    return PropertyVersionInfo;
}(VersionInfo));
exports.PropertyVersionInfo = PropertyVersionInfo;
function createInVersionCheck(model, structureTypeName, versionRange) {
    var version = model.metaModelVersion;
    if (!contains(versionRange, version)) {
        throw new Error("In Mendix version " + version + " it is illegal on instances of " + structureTypeName + " to call the \"createIn\" method, "
            + "either because it's ambiguously contained or derived.");
    }
}
exports.createInVersionCheck = createInVersionCheck;
function isAtLeast(versionString, model) {
    return model.metaModelVersion.isAfterOrEqual(Version.parse(versionString));
}
exports.isAtLeast = isAtLeast;
//# sourceMappingURL=version-checks.js.map
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var structures = require("./structures");
/**
 * See {@link IAbstractElement}.
 */
var AbstractElement = /** @class */ (function (_super) {
    __extends(AbstractElement, _super);
    function AbstractElement(model, structureTypeName, id, isPartial, container) {
        var _this = _super.call(this, model, structureTypeName, id, isPartial, container) || this;
        /** @internal */
        _this._isDoingDelete = false;
        return _this;
    }
    Object.defineProperty(AbstractElement.prototype, "isLoaded", {
        /**
         * Checks whether all properties are available at the moment
         *  - if false, a load is required to access these properties.
         */
        get: function () {
            return this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    AbstractElement.prototype._getQualifiedName = function () {
        var parts = [this.name];
        var containerStructure = this.container;
        var seenRoot = false;
        while (containerStructure) {
            if (containerStructure === this._model.root) {
                seenRoot = true;
            }
            if (containerStructure._declaredAsNamespace) {
                parts.unshift(containerStructure.name);
            }
            containerStructure = containerStructure.container;
        }
        if (!seenRoot || parts.some(function (n) { return !n; })) {
            return null;
        }
        return parts.join(".");
    };
    /**
     * Transforms a IElement interface into a Element class, loading the containing unit if necessary.
     * (Those are technically already the same, but this function makes sure its properties are available.)
     *
     * - If invoked without callback, it checks whether the properties are available or it will throw;
     * - If invoked with callback, it will load the data from the server if needed, and then invoke the callback.
     */
    AbstractElement.prototype.asLoaded = function () {
        this._assertLoaded();
        return this;
    };
    /**
     * Transforms a IElement interface into a Element class, loading the containing unit if necessary.
     * (Those are technically already the same, but this function makes sure its properties are available.)
     *
     * - If invoked without callback, it checks whether the properties are available or it will throw;
     * - If invoked with callback, it will load the data from the server if needed, and then invoke the callback.
     */
    AbstractElement.prototype.load = function (callback, forceRefresh) {
        var _this = this;
        if (!callback) {
            throw new Error("No callback supplied");
        }
        this.unit._model.loadUnitById(this.unit.id, forceRefresh, function () {
            // this element should be loaded now!
            _this._assertLoaded();
            callback(_this);
        });
    };
    /**
     * updateElementsContainer recursively sets the unit to which this elements belong
     * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
     * an element is actually added to the tree (buy pushing / assigning it to some part property)
     *
     * @internal
     */
    AbstractElement.prototype._updateElementsContainer = function (unit) {
        this.allProperties().forEach(function (property) {
            if (property instanceof properties.PartProperty || property instanceof properties.PartListProperty) {
                property.updateElementContainer(unit);
            }
            else if (property instanceof properties.ByIdReferenceProperty) {
                property.updateElementContainer();
            }
        });
    };
    /**
     * Return true if this is an abstractElement that might be referred to by some other element.
     * If true, this element is maintained in the qualifiedNamesCache
     *
     * @internal
     */
    AbstractElement.prototype._isByNameReferrable = function () {
        return false;
    };
    /**
     * Deletes this element from the model.
     */
    AbstractElement.prototype.delete = function () {
        if (this._isDeleted) {
            throw new Error("A deleted element cannot be deleted");
        }
        if (this._isDetached) {
            throw new Error("A detached element cannot be deleted");
        }
        var handle = this.container ? this.container._childHandle(this) : null;
        if (handle) {
            handle.delete();
        }
        else {
            this._deleteInternal();
        }
    };
    /** @internal */
    AbstractElement.prototype._deleteInternal = function () {
        // Make sure that the element does not delete twice.
        if (this._isDoingDelete) {
            return;
        }
        this._isDoingDelete = true;
        var subElements = [];
        this.traverse(function (element) { return subElements.push(element); });
        // Prevent deletion if there are elements refer to this element by-id.
        if (this.unit) {
            var modelUnit = this.unit;
            /**
             * The referredElements map is used for quick lookup of elements that refer to a particular
             * element when performing delete. This leads to considerable performance gain when deleting
             * large widgets, e.g., JSChart.
             */
            var referredElements_1 = {};
            modelUnit.traverse(function (element) {
                if (subElements.indexOf(element) === -1) {
                    element.allProperties()
                        .filter(function (p) { return p instanceof properties.ByIdReferenceProperty; })
                        .forEach(function (p) {
                        if (p.get()) {
                            referredElements_1[p.get().id] = element;
                        }
                    });
                }
            });
            for (var _i = 0, subElements_1 = subElements; _i < subElements_1.length; _i++) {
                var subElement = subElements_1[_i];
                if (referredElements_1[subElement.id]) {
                    throw new Error("Cannot delete this element. There is an element that refers to this element by-id: " + referredElements_1[subElement.id].id);
                }
            }
        }
        _super.prototype._deleteInternal.call(this);
        this._model._qualifiedNameCache.removeStructureFromCache(this);
        this._container = null;
        subElements.forEach(function (element) { return element._state = "deleted"; });
        this._isDoingDelete = false;
    };
    return AbstractElement;
}(structures.Structure));
exports.AbstractElement = AbstractElement;
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    function Element(model, structureTypeName, id, isPartial, unit, container) {
        var _this = _super.call(this, model, structureTypeName, id, isPartial, container) || this;
        if (unit) {
            _this._updateElementsContainer(unit);
        }
        return _this;
    }
    Object.defineProperty(Element.prototype, "unit", {
        get: function () {
            return this._unit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "isLoaded", {
        /**
         * Checks whether all attributes are available ATM
         *  -  if false, a load is required to access these properties.
         */
        get: function () {
            return !this.unit || this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    Element.prototype._updateElementsContainer = function (unit) {
        this._unit = unit;
        this._model = unit._model;
        _super.prototype._updateElementsContainer.call(this, unit);
    };
    /** @internal */
    Element.prototype._scheduleDeltaAfterCreate = function (delta) {
        if (!this._isNew) {
            delta.unitId = this.unit.id;
            this.unit._model._sendDelta(delta);
        }
    };
    /**
     * Sends the appropriate create delta to the server, and also sends all pending deltas,
     * after this element has been assigned to some parent.
     *
     * @internal
     */
    Element.prototype._sendCreateDelta = function (owner, parentPropertyName, additionIndex) {
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        if (owner._isNew) {
            // Parent is not known at the server yet, will be handled when creating it.
            return;
        }
        if (owner.unit) {
            this._updateElementsContainer(owner.unit);
        }
        this.unit._model._sendDelta({
            parentId: owner.id,
            parentPropertyName: parentPropertyName,
            deltaType: "CREATE_ELEMENT_TREE",
            unitId: this.unit.id,
            elementTree: this.toJSON(),
            additionIndex: additionIndex
        });
        this.traverse(function (element) { return element._state = "attached"; });
    };
    /**
     * Sends the appropriate attach delta to the server
     * after this element has been attached to a new parent.
     *
     * @internal
     */
    Element.prototype._sendAttachDelta = function (newParent, newPropertyName, index) {
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var attachDelta = {
            unitId: this.unit.id,
            elementId: this.id,
            deltaType: "ATTACH_ELEMENT",
            newParentId: newParent.id,
            newParentPropertyName: newPropertyName
        };
        if (index !== undefined) {
            attachDelta.newIndex = index;
        }
        this.unit._model._sendDelta(attachDelta);
    };
    /**
     * Detaches this element from the model, so that it can be attached in a different place.
     */
    Element.prototype.detach = function () {
        this._assertLoaded();
        if (!this._isAttached) {
            throw new Error("Only elements that are currently attached can be detached");
        }
        var handle = this.container._childHandle(this);
        this._model._qualifiedNameCache.removeStructureFromCache(this);
        handle.detach();
        this._container = null;
        this._state = "detached";
        this._model._addDetachedStructure(this);
        return this;
    };
    /**
     * Sends the detach delta.
     * @internal
     */
    Element.prototype._sendDetachDelta = function () {
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var detachDelta = {
            unitId: this.unit.id,
            elementId: this.id,
            deltaType: "DETACH_ELEMENT"
        };
        this.unit._model._sendDelta(detachDelta);
    };
    /**
     * Creates a deep copy of this element and its children.
     */
    Element.prototype.deepCopy = function (targetModel) {
        if (!this.isLoaded) {
            throw new Error("Only loaded elements can be copied. Use .load() first");
        }
        if (targetModel.metaModelVersion !== this.model.metaModelVersion) {
            throw new Error("Elements can only be copied between models with the same metamodel version. Tried to copy from " +
                this.model.metaModelVersion + " into " + targetModel.metaModelVersion);
        }
        // Maps old ids to new structures
        var idMap = {};
        // Futures that should fix not yet resolved by-id refs
        var unresolvedIdentifierFixers = [];
        var clone = this._deepCopyElement(targetModel, idMap, unresolvedIdentifierFixers);
        unresolvedIdentifierFixers.forEach(function (fixer) { return fixer(idMap); });
        return clone;
    };
    Element.prototype._deepCopyElement = function (targetModel, idMap, unresolvedIdentifierFixers) {
        var clone = instances_1.instancehelpers.createElement(targetModel, this.constructor);
        idMap[this.id] = clone;
        this.allProperties()
            .filter(function (property) { return property.isAvailable; })
            .forEach(function (property) { return property.deepCopyInto(clone, idMap, unresolvedIdentifierFixers); });
        return clone;
    };
    /** @internal */
    Element.prototype._deepCopyElementInto = function (newParent, targetPropertyName, idMap, unresolvedIdentifierFixers) {
        if (!newParent) {
            throw new Error("Cannot deep copy, no new parent provided");
        }
        else if (!newParent.isLoaded) {
            throw new Error("Cannot deep copy, cannot copy into a target that is not loaded");
        }
        var targetProp = newParent["__" + targetPropertyName];
        if (!targetProp) {
            throw new Error("Cannot deep copy, new parent property does not exist: " + targetPropertyName);
        }
        var clone = this._deepCopyElement(newParent.model, idMap, unresolvedIdentifierFixers);
        if (targetProp instanceof properties.PartListProperty) {
            targetProp.get().push(clone);
        }
        else if (targetProp instanceof properties.PartProperty) {
            targetProp.set(clone);
        }
        else {
            throw new Error("Cannot deep copy, new parent property " + targetPropertyName + " is not a part (list)");
        }
        return clone;
    };
    return Element;
}(AbstractElement));
exports.Element = Element;
// tslint:enable:no-use-before-declare
var properties = require("./properties");
var instances_1 = require("./instances");
//# sourceMappingURL=elements.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var deltas_1 = require("./deltas");
var instances_1 = require("./instances");
var version_checks_1 = require("./version-checks");
var utils_1 = require("../utils");
var properties_1 = require("./properties");
var qualified_name_cache_1 = require("./qualified-name-cache");
// tslint:disable-next-line
var EventEmitter = require("wolfy87-eventemitter");
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
var AbstractModel = /** @class */ (function () {
    function AbstractModel(_client, _errorHandler, _connectionConfig) {
        /** @internal */
        this.detachedStructures = [];
        /**
         * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
         * @internal
         */
        this._units = {};
        /**
         * Map qualifiedName -> AbstractElement[]; the same qualified name could potentially refer to different kind of objects;
         * e.g. MyFirstModule.SecondThing could both be an entity or a microflow.
         *
         * A structure has a qualified name precisely if it's public, publicly contained through namespaces and
         * has a public, 1-string-typed `name` property.
         * In other words: every structure having a qualified name is already present in the interface of the containing unit.
         * So, as soon as the `_processLoadedUnitInterfaces` has been called the cache is complete (no lazy loading).
         * (It still needs to be continuously updated obviously.)
         *
         * @internal
         */
        this._qualifiedNameCache = new qualified_name_cache_1.QualifiedNameCache(this);
        /**
         * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
         * Please extend the type whenever applicable, for convenience of the programmer.
         *
         * @internal
         */
        this._unitsByType = {};
        /** @internal */
        this._areUnitInterfacesLoaded = false;
        /** @internal */
        this.eventEmitter = new EventEmitter();
        this._client = _client;
        this._errorHandler = _errorHandler;
        this._connectionConfig = _connectionConfig;
    }
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
     * or call the errorHandler if this fails.
     */
    AbstractModel.read = function (client, workingCopyId, connectionConfig, instance, callback, errorCallback) {
        AbstractModel.readImpl(instance, workingCopyId, callback);
    };
    AbstractModel.readImpl = function (instance, workingCopyId, callback) {
        // TODO  use promises to avoid callback admin mess
        var hasError = false;
        var processMetaDataCallback;
        var processUnitInterfacesCallback;
        var guardedCallback = function () {
            if (!hasError && processMetaDataCallback && processUnitInterfacesCallback) {
                /*
                 * order is important: metadata (e.g. version) must be set first,
                 * then unit-interfaces (which uses version), then the user can do his/her thing.
                 */
                processMetaDataCallback();
                processUnitInterfacesCallback();
                callback(instance);
            }
        };
        var guardedErrorCallback = function (err) {
            if (!hasError) {
                hasError = true;
                instance._errorHandler(err);
            }
            // Loading is parallel, if multiple errors occur, we are only interested in the first one..
        };
        instance._loadMetaData(workingCopyId, function (processCallback) {
            processMetaDataCallback = processCallback;
            return void guardedCallback();
        }, guardedErrorCallback);
        instance._loadUnitInterfaces(workingCopyId, function (processCallback) {
            processUnitInterfacesCallback = processCallback;
            return void guardedCallback();
        }, guardedErrorCallback);
    };
    AbstractModel.prototype.closeConnection = function (callback, errorCallback) {
        var _this = this;
        setTimeout(function () { return _this.deltaManager.closeConnection(callback, errorCallback); }, 1);
    };
    Object.defineProperty(AbstractModel.prototype, "id", {
        get: function () {
            return this.workingCopy.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractModel.prototype, "_unitTypes", {
        /** @internal */
        get: function () {
            return Object.keys(this._unitsByType);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     *
     * @internal
     */
    AbstractModel.prototype._unitInterfacesByType = function (structureTypeName) {
        if (!(structureTypeName in this._unitsByType)) {
            mobx_1.extendObservable(this._unitsByType, (_a = {}, _a[structureTypeName] = mobx_1.observable.shallowArray(), _a));
        }
        return this._unitsByType[structureTypeName];
        var _a;
    };
    /**
     * Returns a defensive collection of all units in this model.
     */
    AbstractModel.prototype.allUnits = function () {
        var result = [];
        for (var key in this._unitsByType) {
            var objects = this._unitsByType[key];
            result.push.apply(result, objects.slice());
        }
        return result;
    };
    /** @internal */
    AbstractModel.prototype._sendDelta = function (delta) {
        this.deltaManager.push(delta);
    };
    /**
     * Registers the given `unit` in the cache(s).
     *
     * @internal
     */
    AbstractModel.prototype._addUnit = function (unit) {
        if (!unit.structureTypeName) {
            throw new Error("Illegal state: unit has no type name specified");
        }
        if (!this._units[unit.id]) {
            this._units[unit.id] = unit;
            this._unitInterfacesByType(unit.structureTypeName).push(unit);
        }
    };
    /**
     * Unregisters the given `unit` from the cache(s).
     *
     * @internal
     */
    AbstractModel.prototype._removeUnit = function (unit) {
        delete this._units[unit.id];
        var idx = this._unitsByType[unit.structureTypeName].indexOf(unit); // yay for pointer equality
        if (idx > -1) {
            this._unitsByType[unit.structureTypeName].splice(idx, 1);
        }
    };
    AbstractModel.prototype.handleError = function (message, errorCallback) {
        if (errorCallback) {
            errorCallback(new Error(message));
        }
        else {
            this._errorHandler(new Error(message));
        }
    };
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    AbstractModel.prototype.loadUnitById = function (id, forceRefresh, callback, errorCallback) {
        if (id === null) {
            this.handleError("Unit ID is null", errorCallback);
            return;
        }
        var unit = this._units[id];
        if (!unit) {
            this.handleError("Unknown unit ID: " + id, errorCallback);
        }
        else if (forceRefresh) {
            // make sure we can load the unit again:
            unit._markNotLoaded();
            this._loadUnit(unit, callback, errorCallback);
        }
        else if (unit._isLoading) {
            // This cast is ok because when we know that the item being loaded has type T
            unit._registerAfterLoadCallback(callback);
        }
        else if (unit.isLoaded) {
            setTimeout(function () {
                callback(unit);
            }, 1);
        }
        else {
            this._loadUnit(unit, callback, errorCallback);
        }
    };
    /** @internal */
    AbstractModel.prototype._loadUnit = function (unit, callback, errorCallback) {
        var _this = this;
        unit._registerAfterLoadCallback(function (loadedUnit) {
            _this.eventEmitter.emitEvent(AbstractModel.UNIT_LOADED, [loadedUnit.id]);
            callback(loadedUnit);
        });
        unit._markLoading();
        this._client.loadUnitById(this.workingCopy.id, unit.id, function (data) {
            mobx_1.runInAction(function () {
                unit._updateWithJson(data);
                _this._resolveContainer(unit, data.containerId);
                unit.resolveByIdReferences();
            });
            unit._markLoaded();
        }, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.filterUnitsByCustomWidgetId = function (workingCopyId, widgetId, callback, errorCallback) {
        this._client.filterUnitsByCustomWidgetId(workingCopyId, widgetId, callback, errorCallback);
    };
    /** @internal */
    AbstractModel.prototype._loadMetaData = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        this._client.loadWorkingCopyMetaData(workingCopyId, function (data) {
            callback(_this._processLoadedMetaData.bind(_this, data));
        }, errorCallback);
    };
    /** @internal */
    AbstractModel.prototype._processLoadedMetaData = function (data) {
        this.workingCopy = data;
        this.metaModelVersion = version_checks_1.parseAsNormalizedVersion(data.metaData.metaModelVersion);
        this.mxVersionForModel = version_checks_1.parseAsNormalizedVersion(data.mprMetaData._ProductVersion);
        this.deltaManager = new deltas_1.DeltaManager(this);
    };
    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     *
     * @internal
     */
    AbstractModel.prototype._loadUnitInterfaces = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        if (this._areUnitInterfacesLoaded) {
            throw new Error("Illegal state: unit interfaces already loaded");
        }
        this._client.loadUnitInterfaces(workingCopyId, function (data) {
            return void callback(_this._processLoadedUnitInterfaces.bind(_this, data));
        }, errorCallback);
    };
    /** @internal */
    AbstractModel.prototype._processLoadedUnitInterfaces = function (data) {
        var _this = this;
        mobx_1.runInAction(function () {
            data.forEach(function (unitJson) {
                instances_1.instancehelpers.abstractUnitJsonToInstance(_this, unitJson, true);
            });
            data.filter(function (unitJson) { return !!unitJson.containerId; }).forEach(function (unitJson) {
                var unit = _this._units[unitJson.$ID];
                _this._resolveContainer(unit, unitJson.containerId);
            });
            _this._qualifiedNameCache.addStructureToCache(_this.root);
            Object.keys(_this._units).forEach(function (key) { return _this._units[key].resolveByIdReferences(); });
        });
        this._areUnitInterfacesLoaded = true;
    };
    /** @internal */
    AbstractModel.prototype._resolveContainer = function (unit, containerId) {
        if (!unit) {
            return; // can happen as long as the meta model isn't complete.
        }
        var container = this._units[containerId];
        if (!container) {
            throw new Error("Invalid container ID: " + containerId);
        }
        if (container !== unit) {
            // Project has a self reference container, which is of course very annoying for recursion..
            // add unit to the structural parent in the project tree
            this._addUnitToStructuralParent(unit, container);
        }
    };
    /**
     * Structural units have children (e.g., folders have documents), but in storage the inverse is stored:
     * documents specify in which parent they reside.
     * However, in the SDK we want to be able to read the children of a folder, so these kind of properties are expressed
     * using StructuralChild(List)Property objects, see `properties/structural.ts`.
     * We notify structural parents that a child was added upon loading a child structure,
     * so that parent can do the appropriate bookkeeping at that time (and only once).
     * This way we avoid having to visit all unit interfaces to gather all children of a specific structural child (list) property.
     *
     * @internal
     */
    AbstractModel.prototype._addUnitToStructuralParent = function (unit, parent) {
        if (unit.container !== parent) {
            // old container needs to be unset first
            this._removeUnitFromStructuralParent(unit);
        }
        // set the new parent
        unit._container = parent;
        var prop = parent["__" + unit._containmentName];
        parent._isUpdating = true;
        if (prop instanceof properties_1.StructuralChildProperty) {
            prop.observableValue.set(unit);
        }
        else if (prop instanceof properties_1.StructuralChildListProperty) {
            if (prop.observableValue.indexOf(unit) === -1) {
                prop.observableValue.push(unit);
            }
        }
        else {
            throw new Error("Illegal state");
        }
        parent._isUpdating = false;
    };
    /** @internal */
    AbstractModel.prototype._removeUnitFromStructuralParent = function (unit) {
        if (!unit.container) {
            return;
        }
        var oldParent = unit.container;
        var oldProp = oldParent["__" + unit._containmentName];
        oldParent._isUpdating = true;
        if (oldProp instanceof properties_1.StructuralChildProperty) {
            oldProp.observableValue.set(null);
        }
        else if (oldProp instanceof properties_1.StructuralChildListProperty) {
            oldProp.observableValue.remove(unit);
        }
        else {
            throw new Error("Illegal state");
        }
        oldParent._isUpdating = false;
        unit._container = null;
    };
    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     *
     * @internal
     */
    AbstractModel.prototype._processNameChange = function (structure) {
        if (instances_1.instancehelpers.structureAffectsQualifiedNames(structure)) {
            this._qualifiedNameCache.addStructureToCache(structure);
        }
    };
    /** @internal */
    AbstractModel.prototype._addDetachedStructure = function (structure) {
        if (this.detachedStructures.indexOf(structure) === -1) {
            this.detachedStructures.push(structure);
        }
    };
    /** @internal */
    AbstractModel.prototype._removeDetachedStructure = function (structure) {
        var index = this.detachedStructures.indexOf(structure);
        if (index >= 0) {
            this.detachedStructures.splice(index, 1);
        }
    };
    /** @internal */
    AbstractModel.prototype._assertConnectionClosed = function () {
        if (!this.deltaManager.isClosing) {
            throw new Error("Connection should be closed first");
        }
    };
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    AbstractModel.prototype.deleteWorkingCopy = function (callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.deleteWorkingCopy(this.id, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.exportMpk = function (outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportMpk(this.id, outFilePath, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.exportModuleMpk = function (moduleId, outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportModuleMpk(this.id, moduleId, outFilePath, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.getFilePaths = function (callback, errorCallback) {
        this.getFiles(callback, errorCallback);
    };
    AbstractModel.prototype.getFiles = function (arg1, arg2, arg3) {
        var cb, errorCb, options;
        if (typeof arg1 === "function") {
            cb = arg1;
            errorCb = arg2;
            options = {
                format: "json"
            };
        }
        else {
            options = arg1;
            cb = arg2;
            errorCb = arg3;
        }
        this._client.getFiles(this.id, options, cb, errorCb);
    };
    AbstractModel.prototype.getFile = function (filePath, outFilePath, callback, errorCallback) {
        this._client.getFile(this.id, filePath, outFilePath, callback, errorCallback);
    };
    AbstractModel.prototype.putFile = function (inFilePath, filePath, callback, errorCallback) {
        this._client.putFile(this.id, inFilePath, filePath, callback, errorCallback);
    };
    AbstractModel.prototype.deleteFile = function (filePath, callback, errorCallback) {
        this._client.deleteFile(this.id, filePath, callback, errorCallback);
    };
    AbstractModel.prototype.getAppEnvironmentStatus = function (callback, errorCallback) {
        this._client.getAppEnvironmentStatus(this.id, callback, errorCallback);
    };
    AbstractModel.prototype.getAppUpdateStatus = function (jobId, callback, errorCallback) {
        this._client.getAppUpdateStatus(this.id, jobId, callback, errorCallback);
    };
    AbstractModel.prototype.startAppUpdate = function (callback, errorCallback) {
        this._client.startAppUpdate(this.id, callback, errorCallback);
    };
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.structureTypeName, "Expenses.Expense.Price");`
     *
     * @internal
     */
    AbstractModel.prototype._resolveName = function (structureTypeName, qualifiedName) {
        return this._qualifiedNameCache.resolve(structureTypeName, qualifiedName);
    };
    /** @internal */
    AbstractModel.prototype._warnAboutUnsupportedType = function (propertyName, qname) {
        utils_1.utils.warnOnce("Cannot resolve identifier; the type of the identifiers used by property '" + propertyName + "' is currently not supported. "
            + ("Please use the property '." + propertyName + "QualifiedName' instead to read or update this reference."));
    };
    /** @internal */
    AbstractModel.prototype._allOfTypes = function (structureTypeNames) {
        var _this = this;
        return utils_1.utils.flatten(structureTypeNames.map(function (structureTypeName) { return _this._unitInterfacesByType(structureTypeName); }));
    };
    /** @internal */
    AbstractModel.prototype.onUnitLoaded = function (callback) {
        this.eventEmitter.on(AbstractModel.UNIT_LOADED, callback);
    };
    AbstractModel.UNIT_LOADED = "UnitLoaded";
    return AbstractModel;
}());
exports.AbstractModel = AbstractModel;
//# sourceMappingURL=abstract-model.js.map
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var abstract_property_1 = require("./abstract-property");
var primitives_1 = require("./primitives");
var utils_1 = require("../../utils");
function checkElementIsByNameReferrable(element, propertyName, operation) {
    if (!element) {
        return;
    }
    if (!element._isAttached) {
        throw new Error("Cannot " + operation + " an element that is not currently attached to the model to property '" + propertyName + "'. ");
    }
    if (element._getQualifiedName() === null) {
        throw new Error("Cannot " + operation + " an element of which the qualified name is not valid yet to property '" + propertyName + "'. " +
            "Make sure that the element itself and all of its named containers have a valid name first.");
    }
}
/**
 * Property value that references a (model) element by name.
 */
var ByNameReferenceProperty = /** @class */ (function (_super) {
    __extends(ByNameReferenceProperty, _super);
    function ByNameReferenceProperty(declaredOn, parent, name, initialValue, _targetType) {
        var _this = _super.call(this, declaredOn, parent, name, initialValue, _targetType) || this;
        _this._targetType = _targetType;
        return _this;
    }
    /** @internal */
    ByNameReferenceProperty.prototype.initialize = function (value, _targetType) {
        var _this = this;
        var qualifiedName = value ? value._getQualifiedName() : null;
        var observableValue = mobx_1.observable(qualifiedName);
        observableValue.intercept(function (change) { return _this.beforeChange(change); });
        return { observableValue: observableValue };
    };
    ByNameReferenceProperty.prototype.get = function () {
        this.assertReadable();
        var qualifiedName = this.qualifiedName();
        return qualifiedName ? this.parent._model._resolveName(this._targetType, qualifiedName) : null;
    };
    ByNameReferenceProperty.prototype.set = function (newValue) {
        this.assertWritable();
        if (this.isRequired && !newValue) {
            throw new Error("Cannot unset required property '" + this.name + "' on instance of type '" + this.parent.structureTypeName + "'");
        }
        checkElementIsByNameReferrable(newValue, this.name, "assign");
        this.observableValue.set(newValue ? newValue._getQualifiedName() : null);
    };
    ByNameReferenceProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.set(value === "" ? null : value);
    };
    /** @internal */
    ByNameReferenceProperty.prototype.beforeChange = function (change) {
        if (this.shouldHandleChange()) {
            this.parent._sendChangeDelta(this.name, change.newValue);
        }
        return change;
    };
    ByNameReferenceProperty.prototype.qualifiedName = function () {
        return this.observableValue.get();
    };
    /**
     * This method is used to update the qualified name as part of a rename.
     * _skipOnChange is used to prevent sending deltas for this change, as the Model Server handles this itself.
     *
     * @internal
     */
    ByNameReferenceProperty.prototype.updateQualifiedNameForRename = function (value) {
        this._skipOnChange = true;
        this.updateWithRawValue(value);
        this._skipOnChange = false;
    };
    Object.defineProperty(ByNameReferenceProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ByNameReferenceProperty.prototype._toJSON = function () {
        return this.qualifiedName() || null;
    };
    ByNameReferenceProperty.prototype.deepCopyInto = function (clone, idMap, unresolvedIdentifierFixers) {
        // make sure we copy the refs, not the values, refs might be broken.
        clone["__" + this.name].updateWithRawValue(this.qualifiedName());
    };
    return ByNameReferenceProperty;
}(abstract_property_1.AbstractProperty));
exports.ByNameReferenceProperty = ByNameReferenceProperty;
/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
var ByNameReferenceListProperty = /** @class */ (function (_super) {
    __extends(ByNameReferenceListProperty, _super);
    function ByNameReferenceListProperty(declaredOn, parent, name, value, _targetType) {
        var _this = _super.call(this, declaredOn, parent, name, value) || this;
        /** @internal */
        _this._suppressViewEvents = false;
        /** @internal */
        _this._viewList = mobx_1.observable.shallowArray();
        _this._targetType = _targetType;
        _this._viewList.intercept(function (change) {
            if (_this._suppressViewEvents) {
                return change;
            }
            _this.assertWritable();
            switch (change.type) {
                case "splice":
                    change.added.forEach(function (newValue) {
                        utils_1.utils.assertNotNull(newValue, _this.name, true);
                        checkElementIsByNameReferrable(newValue, _this.name, "add");
                    });
                    break;
                case "update":
                    if (change.index < 0 || change.index >= _this.observableValue.length) {
                        throw new Error("Update index out of bounds " + change.index);
                    }
                    utils_1.utils.assertNotNull(change.newValue, _this.name, true);
                    checkElementIsByNameReferrable(change.newValue, _this.name, "add");
                    break;
            }
            return change;
        });
        _this._viewListObserverDisposer = _this._viewList.observe(function (change) {
            if (_this._suppressViewEvents) {
                return;
            }
            // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
            switch (change.type) {
                case "splice":
                    var newQualifiedNames = change.added
                        .map(function (newValue) { return newValue._getQualifiedName(); });
                    (_a = _this.observableValue).splice.apply(_a, [change.index, change.removed.length].concat(newQualifiedNames));
                    break;
                case "update":
                    // tslint:disable-next-line:no-unnecessary-type-assertion
                    _this.observableValue[change.index] = change.newValue._getQualifiedName();
                    break;
            }
            var _a;
        });
        var getElementsFromCache = function () {
            return _this.observableValue.map(function (qualifiedName) { return _this.parent._model._resolveName(_this._targetType, qualifiedName); });
        };
        var updateViewList = function (newElements) {
            var oldElements = _this._viewList.slice();
            if (utils_1.utils.shallowEquals(oldElements, newElements)) {
                return;
            }
            _this._suppressViewEvents = true;
            _this._viewList.replace(newElements);
            _this._suppressViewEvents = false;
        };
        _this._viewListUpdaterDisposer = mobx_1.reaction(getElementsFromCache, updateViewList, true);
        return _this;
    }
    /** @internal */
    ByNameReferenceListProperty.prototype.initialize = function (value) {
        var _this = this;
        if (value && value.length > 0) {
            throw new Error("Illegal state: can only initialize with []");
        }
        var observableValue = mobx_1.observable.shallowArray();
        observableValue.intercept(function (change) { return _this.beforeChange(change); });
        return { observableValue: observableValue };
    };
    ByNameReferenceListProperty.prototype.get = function () {
        this.assertReadable();
        return this._viewList;
    };
    ByNameReferenceListProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.replace(value);
    };
    ByNameReferenceListProperty.prototype.qualifiedNames = function () {
        return this.observableValue.slice();
    };
    /**
     * This method is used to update the qualified names as part of a rename.
     * _skipOnChange is used to prevent sending deltas for this change, as the Model Server handles this itself.
     *
     * @internal
     */
    ByNameReferenceListProperty.prototype.updateQualifiedNamesForRename = function (qualifiedNames) {
        this._skipOnChange = true;
        this.updateWithRawValue(qualifiedNames);
        this._skipOnChange = false;
    };
    ByNameReferenceListProperty.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._viewListObserverDisposer();
        this._viewListUpdaterDisposer();
    };
    /** @internal */
    ByNameReferenceListProperty.prototype.beforeChange = function (change) {
        if (this.shouldHandleChange()) {
            primitives_1.sendListChangeDeltas(this, change);
        }
        return change;
    };
    /** @internal */
    ByNameReferenceListProperty.prototype.toRawChangeValue = function (qualifiedName) {
        return qualifiedName;
    };
    Object.defineProperty(ByNameReferenceListProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ByNameReferenceListProperty.prototype._toJSON = function () {
        return this.qualifiedNames();
    };
    ByNameReferenceListProperty.prototype.deepCopyInto = function (clone, idMap, unresolvedIdentifierFixers) {
        // make sure we copy the refs, not the values, refs might be broken.
        clone["__" + this.name].updateWithRawValue(this.qualifiedNames());
    };
    return ByNameReferenceListProperty;
}(abstract_property_1.AbstractProperty));
exports.ByNameReferenceListProperty = ByNameReferenceListProperty;
//# sourceMappingURL=by-name-reference.js.map
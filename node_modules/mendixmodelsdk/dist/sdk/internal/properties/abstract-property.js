"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
var AbstractProperty = /** @class */ (function () {
    function AbstractProperty(declaredOn, parent, name) {
        var initializeArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            initializeArgs[_i - 3] = arguments[_i];
        }
        this.declaredOn = declaredOn;
        this.parent = parent;
        this.name = name;
        /** @internal */
        this._skipOnChange = false;
        parent._registerProperty(this);
        var initializeResult = this.initialize.apply(this, initializeArgs);
        this.observableValue = initializeResult.observableValue;
        this.disposer = initializeResult.disposer;
    }
    Object.defineProperty(AbstractProperty.prototype, "versionInfo", {
        get: function () {
            return this.declaredOn.versionInfo.getPropertyVersionInfo(this.name);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isPublic", {
        get: function () {
            return this.versionInfo.isPublic.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isRequired", {
        get: function () {
            return this.versionInfo.isRequired.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isAvailable", {
        /**
         * Returns true if this property is not deleted, and already availabe in the current model version.
         */
        get: function () {
            return this.versionInfo.availability.isAvailableIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    AbstractProperty.prototype.shouldHandleChange = function () {
        return !this.parent._isUpdating && !this._skipOnChange;
    };
    /** @internal */
    AbstractProperty.prototype.assertWritable = function () {
        this.parent._assertLoaded(this);
        if (this.parent._isDeleted) {
            throw new Error("Cannot write properties of deleted element");
        }
        this.assertPropertyAvailableInCurrentVersion();
    };
    /** @internal */
    AbstractProperty.prototype.assertReadable = function () {
        if (!this.isPublic) {
            this.parent._assertLoaded(this);
        }
        this.assertPropertyAvailableInCurrentVersion();
    };
    /** @internal */
    AbstractProperty.prototype.assertPropertyAvailableInCurrentVersion = function () {
        // parent check is done here and not in property info, because the actual type of the structure
        // might have different version annations as the type that declared the property
        this.parent.versionInfo.checkStructureVersion(this.parent, true);
        this.versionInfo.checkPropertyVersion(this, true);
    };
    AbstractProperty.prototype.dispose = function () {
        if (this.disposer) {
            this.disposer();
        }
    };
    return AbstractProperty;
}());
exports.AbstractProperty = AbstractProperty;
//# sourceMappingURL=abstract-property.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_model_1 = require("./abstract-model");
var versions = require("./version-checks");
var units = require("./units");
var elements = require("./elements");
var utils_1 = require("../utils");
/**
 * Base class for enumerations in the meta model.
 * Literals of an enumeration are generated as public static constants of the generated sub class
 * which are instances of the generated sub class.
 */
var AbstractEnum = /** @class */ (function () {
    function AbstractEnum(_name, lifeCycleInfo) {
        this._name = _name;
        this.versionInfo = new versions.LifeCycle(lifeCycleInfo);
    }
    Object.defineProperty(AbstractEnum.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    AbstractEnum.prototype.toString = function () {
        return this._name;
    };
    AbstractEnum.prototype.qualifiedTsLiteralName = function () {
        return this.qualifiedTsTypeName + "." + this._name;
    };
    AbstractEnum.prototype.checkEnumVersion = function (metaModelVersion, includeWarnings) {
        this.versionInfo.reportVersionIssues(metaModelVersion, "Enumeration value '" + this.qualifiedTsLiteralName + "'", includeWarnings);
    };
    return AbstractEnum;
}());
exports.AbstractEnum = AbstractEnum;
// namespace is a workaround for typedoc
var instancehelpers;
(function (instancehelpers) {
    /**
     * Given some a (normalized) JSON representation of a unit,
     * creates an instance of the corresponding `unit.AbstractUnit` sub class (structural/model)
     * and populates that from the JSON.
     * Should only be called if this unit was not already in memory.
     */
    function abstractUnitJsonToInstance(model, json, isPartial) {
        if (!json) {
            return null;
        }
        var unit = createStructureFromJson(lookupClass(json.$Type, model._allModelClasses()), function (id) { return model._units[id]; }, function (initializer) { return new initializer(model, json.$Type, json.$ID, isPartial, null); }, json);
        if (unit) {
            model._addUnit(unit);
        }
        return unit;
    }
    instancehelpers.abstractUnitJsonToInstance = abstractUnitJsonToInstance;
    /**
     * Given some a (normalized) JSON representation of a model element,
     * creates an instance of the corresponding `elements.Element`
     * and populates that from the JSON.
     * Will update existing elements if this element was created before.
     */
    function modelElementJsonToInstance(model, unit, container, json, isPartial) {
        if (!json) {
            return null;
        }
        return createStructureFromJson(lookupClass(json.$Type, model._allModelClasses()), function (id) { return unit.findElementById(id); }, function (initializer) { return new initializer(model, json.$Type, json.$ID, isPartial, unit, container); }, json);
    }
    instancehelpers.modelElementJsonToInstance = modelElementJsonToInstance;
    /**
     * Creates a new element for a SDK user.
     */
    function createElement(owner, constructor, parentPropName, parentPropIsList) {
        if (!owner) {
            throw new Error("Please provide a container or model");
        }
        var model = owner instanceof abstract_model_1.AbstractModel ? owner : owner._model;
        var instance = new constructor(model, constructor.structureTypeName, utils_1.utils.randomUuid(), false, null, null);
        checkStructureVersion(instance, true);
        instance._initializeNewInstance();
        if (parentPropName && (!(owner instanceof abstract_model_1.AbstractModel))) {
            if (parentPropIsList) {
                owner[parentPropName].push(instance);
            }
            else {
                owner[parentPropName] = instance;
            }
        }
        return instance;
    }
    instancehelpers.createElement = createElement;
    /**
     * Creates a new unit for a SDK user.
     */
    function createUnit(container, constructor) {
        if (!(container instanceof units.StructuralUnit)) {
            throw new Error("Expected container");
        }
        var model = container._model;
        var instance = new constructor(model, constructor.structureTypeName, utils_1.utils.randomUuid(), false, container);
        checkStructureVersion(instance, true);
        instance._initializeNewInstance();
        instance._handleCreateSelf();
        model._addUnitToStructuralParent(instance, container);
        model._addUnit(instance);
        return instance;
    }
    instancehelpers.createUnit = createUnit;
    /**
     * Type -> class (the constructor function, technically) lookup, e.g. "DomainModels$Entity" -> DomainModels.Entity
     */
    function lookupClass(qualifiedTypeName, classes) {
        if (!qualifiedTypeName) {
            throw new Error("cannot look up initializer for a falsy qualified type name");
        }
        var $index = qualifiedTypeName.indexOf("$");
        if ($index < 0 || $index === qualifiedTypeName.length - 1) {
            throw new Error("qualified type '" + qualifiedTypeName + "' is not of the form '<meta model>$<type name>");
        }
        var metaModelName = qualifiedTypeName.substring(0, $index).toLowerCase();
        var className = qualifiedTypeName.substring($index + 1);
        if (!classes[metaModelName]) {
            throw new Error("no meta model with name '" + metaModelName + "' exists");
        }
        if (!classes[metaModelName][className]) {
            throw new Error("no type with name '" + metaModelName + "$" + className + " exists");
        }
        return classes[metaModelName][className];
    }
    instancehelpers.lookupClass = lookupClass;
    function structureAffectsQualifiedNames(structure) {
        return structure._declaredAsNamespace || structureIsByNameReferrable(structure);
    }
    instancehelpers.structureAffectsQualifiedNames = structureAffectsQualifiedNames;
    function structureIsByNameReferrable(structure) {
        return structure instanceof elements.AbstractElement && structure._isByNameReferrable();
    }
    instancehelpers.structureIsByNameReferrable = structureIsByNameReferrable;
})(instancehelpers = exports.instancehelpers || (exports.instancehelpers = {}));
function checkStructureVersion(instance, includeWarnings) {
    instance.versionInfo.checkStructureVersion(instance, includeWarnings);
}
function _createInstanceWithInitializer(initializer, callback, json) {
    var instance = callback(initializer);
    instance._updateWithJsonImpl(json);
    instance._isUpdating = false; // initialization is done
    checkStructureVersion(instance, false);
    return instance;
}
/**
 * Creates (deserializes) a structure based on incoming JSON.
 */
function createStructureFromJson(initializer, findInstance, callback, json) {
    var structure = findInstance(json.$ID);
    if (structure) {
        structure._updateWithJson(json);
        // TODO: what if container was changed?
        return structure;
    }
    return _createInstanceWithInitializer(initializer, callback, json);
}
//# sourceMappingURL=instances.js.map
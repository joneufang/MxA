import { common } from "../../common";
import { configuration } from "../config";
import { IAbstractUnit, IStructuralUnit } from "./units";
import { IWorkingCopy, IGetFilesOptions, IEnvironmentStatus, IDeployJobStatus } from "./transport-interfaces";
import { IModelServerClient } from "./model-server-client";
import { IStructure } from "./structures";
import { Version } from "./version-checks";
/**
 * This interface exposes a single Mendix Model.
 * This interface contains the parts of the {@link Model} that are exposed through the SDK.
 */
export interface IAbstractModel {
    /**
     * Working copy id of the current opened model (read only)
     */
    id: string;
    /**
     * The meta data of the model.
     */
    workingCopy: IWorkingCopy;
    /**
     * The Mendix meta model version related to the project.
     */
    metaModelVersion: Version;
    /**
     * The Mendix product version the model was created with/in.
     * Note: this does not have to equal the meta model version.
     */
    mxVersionForModel: Version;
    /**
     * Ends the connection with the Model API client.
     * Flushes any pending deltas and invokes the callback once complete.
     * (Errors will be handled through the default modelstore error handler.)
     */
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Deletes this model from the server, and the (SDK) client.
     * If you are altering the model before deleting it, make sure to call this method in the callback of {@link closeConnection}.
     *
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Exports this model as MPK.
     * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
     * If outFilePath is empty, the raw request response will be provided in the callback
     */
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Exports the module as MPK.
     * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
     * If outFilePath is empty, the raw request response will be provided in the callback
     */
    exportModuleMpk(moduleId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Get the deployment status of the working copy. Can be STARTED, STARTING, UPDATING, STOPPED and APP_NOT_FOUND.
     * Contains other deployment info as well.
     */
    getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback: common.IErrorCallback): void;
    /**
     * Start async deploy flow, creates new app job and returns it.
     * This call immediately returns after successfully initiating the deployment job, and it's progress
     * can be tracked using `getAppUpdateStates.
     *
     * A start update packs the mpk and sends it to the the cloud environment to update the application,
     * a new application will be provisioned if needed.
     *
     * The update job will always converge to a stable state (one of "started" | "failed" | "consistencyerrors").
     * Use the returned job id to poll for this.
     */
    startAppUpdate(callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    /**
     * Retrieves App Job by jobId. See also `startAppUpdate`.
     * In the response the most important field is status.
     *
     * Polling for job status should stop once it has reeached "started" | "failed" | "consistencyerrors".
     * Jobs will be cleaned up 10 minutes after the have reached one of this states.
     */
    getAppUpdateStatus(jobId: string, callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    /**
     * Given an id, fetches a complete unit. The result might be returned from the cache.
     * Use this method if you have just a unit Id, otherwise, unit.fetch() is a simpler alternative.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, forceRefresh: boolean, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): void;
    /**
     * Returns a list of unitIds that contains a specific custom widget
     */
    filterUnitsByCustomWidgetId(workingCopyId: string, widgetId: string, callback: common.ICallback<string[]>, errorCallback?: common.IErrorCallback): void;
    /**
     * Returns all units in the project, including modules, folders etc.
     * To retrieve all "real" documents (pages, microflows etc.), use allDocuments().
     */
    allUnits(): IAbstractUnit[];
    /**
     * Returns an array of all filepaths in the working copy.
     */
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    /**
     * Returns all files or a subset of files
     * options.filter: glob pattern to limit the set of files
     * options.format: "json" or "zip"
     * options.path: useful if format is "zip". If provided the zip will be stored on disk
     */
    getFiles(callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback): void;
    getFiles(options: IGetFilesOptions, callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback): void;
    /**
     * Downloads the file specified by the supplied filepath.
     * If filePath is empty, the raw request response will be provided in the callback
     */
    getFile(filePath: string, outFilePath: string, callback: (response?: any) => void, errorCallback: common.IErrorCallback): void;
    /**
     * Uploads the supplied file to the specified filepath.
     */
    putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    /**
     * Deletes the file with the specified filepath.
     */
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
}
export interface IUnitsMap {
    [id: string]: IAbstractUnit;
}
export interface IUnitsByTypeCache {
    [type: string]: IAbstractUnit[];
}
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
export declare abstract class AbstractModel implements IAbstractModel {
    workingCopy: IWorkingCopy;
    metaModelVersion: Version;
    mxVersionForModel: Version;
    readonly abstract root: IStructuralUnit;
    private static UNIT_LOADED;
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
     * or call the errorHandler if this fails.
     */
    static read<IT extends IAbstractModel, CT extends AbstractModel & IT>(client: IModelServerClient, workingCopyId: string, connectionConfig: configuration.ISdkConfig, instance: CT, callback: (model: IT) => void, errorCallback: common.IErrorCallback): void;
    private static readImpl<IT, CT>(instance, workingCopyId, callback);
    constructor(_client: IModelServerClient, _errorHandler: common.IErrorCallback, _connectionConfig: configuration.ISdkConfig);
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    readonly id: string;
    /**
     * Returns a defensive collection of all units in this model.
     */
    allUnits(): IAbstractUnit[];
    handleError(message: string, errorCallback: common.IErrorCallback | undefined): void;
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, forceRefresh: boolean | undefined, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): void;
    filterUnitsByCustomWidgetId(workingCopyId: string, widgetId: string, callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    exportModuleMpk(moduleId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    getFiles(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    getFiles(options: IGetFilesOptions, callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    getFile(filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback: common.IErrorCallback): void;
    getAppUpdateStatus(jobId: string, callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    startAppUpdate(callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
}
export interface ISubResolver {
    (parent: IStructure, partName: string): IStructure;
}
